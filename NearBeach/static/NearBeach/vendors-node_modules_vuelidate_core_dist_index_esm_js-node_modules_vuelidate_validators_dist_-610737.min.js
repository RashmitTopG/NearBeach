"use strict";
(self["webpackChunknearbeach"] = self["webpackChunknearbeach"] || []).push([["vendors-node_modules_vuelidate_core_dist_index_esm_js-node_modules_vuelidate_validators_dist_-610737"],{

/***/ "./node_modules/@vuelidate/core/dist/index.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@vuelidate/core/dist/index.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectFlag": () => (/* binding */ CollectFlag),
/* harmony export */   "default": () => (/* binding */ useVuelidate),
/* harmony export */   "useVuelidate": () => (/* binding */ useVuelidate)
/* harmony export */ });
/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-demi */ "./node_modules/@vuelidate/core/node_modules/vue-demi/lib/index.mjs");


function unwrapObj(obj) {
  let ignoreKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return Object.keys(obj).reduce((o, k) => {
    if (ignoreKeys.includes(k)) return o;
    o[k] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(obj[k]);
    return o;
  }, {});
}
function isFunction(val) {
  return typeof val === 'function';
}
function isProxy(value) {
  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isReactive)(value) || (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(value);
}

/**
 * Response form a raw Validator function.
 * Should return a Boolean or an object with $invalid property.
 * @typedef {Boolean | { $valid: Boolean }} ValidatorResponse
 */

/**
 * Calls a validation rule by unwrapping its value first from a ref.
 * @param {Validator} rule
 * @param {Ref} value
 * @param {VueInstance} instance
 * @param {Object} siblingState
 * @return {Promise<ValidatorResponse> | ValidatorResponse}
 */

function callRule(rule, value, siblingState, instance) {
  return rule.call(instance, (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(value), (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(siblingState), instance);
}
/**
 * Normalizes the validator result
 * Allows passing a boolean of an object like `{ $valid: Boolean }`
 * @param {ValidatorResponse} result - Validator result
 * @return {boolean}
 */


function normalizeValidatorResponse(result) {
  return result.$valid !== undefined ? !result.$valid : !result;
}
/**
 * Returns the result of an async validator.
 * @param {Validator} rule
 * @param {Ref<*>} model
 * @param {Ref<Boolean>} $pending
 * @param {Ref<Boolean>} $dirty
 * @param {GlobalConfig} config
 * @param {boolean} config.$lazy
 * @param {Ref<*>} $response
 * @param {VueInstance} instance
 * @param {Ref<*>[]} watchTargets
 * @param {Object} siblingState
 * @param {Ref<Boolean>} $lastInvalidState
 * @param {Ref<Number>} $lastCommittedOn
 * @return {{ $invalid: Ref<Boolean>, $unwatch: WatchStopHandle }}
 */


function createAsyncResult(rule, model, $pending, $dirty, _ref, $response, instance) {
  let {
    $lazy,
    $rewardEarly
  } = _ref;
  let watchTargets = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];
  let siblingState = arguments.length > 8 ? arguments[8] : undefined;
  let $lastInvalidState = arguments.length > 9 ? arguments[9] : undefined;
  let $lastCommittedOn = arguments.length > 10 ? arguments[10] : undefined;
  const $invalid = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(!!$dirty.value);
  const $pendingCounter = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(0);
  $pending.value = false;
  const $unwatch = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)([model, $dirty].concat(watchTargets, $lastCommittedOn), () => {
    if ( // if $lazy and not dirty, return
    $lazy && !$dirty.value || // if in $rewardEarly mode and no previous errors, nothing pending, return
    $rewardEarly && !$lastInvalidState.value && !$pending.value) {
      return;
    }

    let ruleResult; // make sure we dont break if a validator throws

    try {
      ruleResult = callRule(rule, model, siblingState, instance);
    } catch (err) {
      // convert to a promise, so we can handle it async
      ruleResult = Promise.reject(err);
    }

    $pendingCounter.value++;
    $pending.value = !!$pendingCounter.value; // ensure $invalid is false, while validator is resolving

    $invalid.value = false;
    Promise.resolve(ruleResult).then(data => {
      $pendingCounter.value--;
      $pending.value = !!$pendingCounter.value;
      $response.value = data;
      $invalid.value = normalizeValidatorResponse(data);
    }).catch(error => {
      $pendingCounter.value--;
      $pending.value = !!$pendingCounter.value;
      $response.value = error;
      $invalid.value = true;
    });
  }, {
    immediate: true,
    deep: typeof model === 'object'
  });
  return {
    $invalid,
    $unwatch
  };
}
/**
 * Returns the result of a sync validator
 * @param {Validator} rule
 * @param {Ref<*>} model
 * @param {Ref<Boolean>} $dirty
 * @param {GlobalConfig} config
 * @param {Boolean} config.$lazy
 * @param {Ref<*>} $response
 * @param {VueInstance} instance
 * @param {Object} siblingState
 * @param {Ref<Boolean>} $lastInvalidState
 * @return {{$unwatch: (function(): {}), $invalid: ComputedRef<boolean>}}
 */


function createSyncResult(rule, model, $dirty, _ref2, $response, instance, siblingState, $lastInvalidState) {
  let {
    $lazy,
    $rewardEarly
  } = _ref2;

  const $unwatch = () => ({});

  const $invalid = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
    if ( // return early if $lazy mode and not touched
    $lazy && !$dirty.value || // If $rewardEarly mode is ON and last invalid was false (no error), return it.
    // If we want to invalidate, we just flip the last state to true, causing the computed to run again
    $rewardEarly && !$lastInvalidState.value) {
      return false;
    }

    let returnValue = true;

    try {
      const result = callRule(rule, model, siblingState, instance);
      $response.value = result;
      returnValue = normalizeValidatorResponse(result);
    } catch (err) {
      $response.value = err;
    }

    return returnValue;
  });
  return {
    $unwatch,
    $invalid
  };
}
/**
 * Returns the validation result.
 * Detects async and sync validators.
 * @param {NormalizedValidator} rule
 * @param {Ref<*>} model
 * @param {Ref<boolean>} $dirty
 * @param {GlobalConfig} config - Vuelidate config
 * @param {VueInstance} instance - component instance
 * @param {string} validatorName - name of the current validator
 * @param {string} propertyKey - the current property we are validating
 * @param {string} propertyPath - the deep path to the validated property
 * @param {Object} siblingState
 * @param {Ref<Boolean>} $lastInvalidState - the last invalid state
 * @param {Ref<Number>} $lastCommittedOn - the last time $commit was called
 * @return {{ $params: *, $message: Ref<String>, $pending: Ref<Boolean>, $invalid: Ref<Boolean>, $response: Ref<*>, $unwatch: WatchStopHandle }}
 */


function createValidatorResult(rule, model, $dirty, config, instance, validatorName, propertyKey, propertyPath, siblingState, $lastInvalidState, $lastCommittedOn) {
  const $pending = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
  const $params = rule.$params || {};
  const $response = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
  let $invalid;
  let $unwatch;

  if (rule.$async) {
    ({
      $invalid,
      $unwatch
    } = createAsyncResult(rule.$validator, model, $pending, $dirty, config, $response, instance, rule.$watchTargets, siblingState, $lastInvalidState, $lastCommittedOn));
  } else {
    ({
      $invalid,
      $unwatch
    } = createSyncResult(rule.$validator, model, $dirty, config, $response, instance, siblingState, $lastInvalidState));
  }

  const message = rule.$message;
  const $message = isFunction(message) ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => message(unwrapObj({
    $pending,
    $invalid,
    $params: unwrapObj($params),
    // $params can hold refs, so we unwrap them for easy access
    $model: model,
    $response,
    $validator: validatorName,
    $propertyPath: propertyPath,
    $property: propertyKey
  }))) : message || '';
  return {
    $message,
    $params,
    $pending,
    $invalid,
    $response,
    $unwatch
  };
}

/**
 * Sorts a validation definition into rules, configs and nested validators.
 * @param {Object<NormalizedValidator|Function>} validationsRaw
 * @return {{ rules: Object<NormalizedValidator>, nestedValidators: Object, config: GlobalConfig }}
 */

function sortValidations() {
  let validationsRaw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const validations = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(validationsRaw);
  const validationKeys = Object.keys(validations);
  const rules = {};
  const nestedValidators = {};
  const config = {};
  validationKeys.forEach(key => {
    const v = validations[key];

    switch (true) {
      // If it is already normalized, use it
      case isFunction(v.$validator):
        rules[key] = v;
        break;
      // If it is just a function, normalize it first
      // into { $validator: <Fun> }

      case isFunction(v):
        rules[key] = {
          $validator: v
        };
        break;
      // Catch $-prefixed properties as config

      case key.startsWith('$'):
        config[key] = v;
        break;
      // If it doesnâ€™t match any of the above,
      // treat as nestedValidators state property

      default:
        nestedValidators[key] = v;
    }
  });
  return {
    rules,
    nestedValidators,
    config
  };
}

function _empty() {}

const ROOT_PATH = '__root';
/** @typedef {import('vue-demi').ComponentPublicInstance} VueInstance */

/** @typedef {import('vue-demi').ComputedRef} ComputedRef */

/** @typedef {import('vue-demi').UnwrapRef} UnwrapRef */

/** @typedef {import('vue-demi').WatchStopHandle} WatchStopHandle */

/** @typedef {import('vue-demi').WritableComputedRef} WritableComputedRef */

/** @typedef {import('vue-demi').UnwrapNestedRefs} UnwrapNestedRefs */

/**
 * @typedef NormalizedValidator
 * @property {Validator} $validator
 * @property {String | Ref<String> | function(*): string} [$message]
 * @property {Object | Ref<Object>} [$params]
 * @property {Object | Ref<Object>} [$async]
 * @property {Ref<*>[]} [$watchTargets]
 */

/**
 * Raw validator function, before being normalized
 * Can return a Promise or a {@see ValidatorResponse}
 * @typedef {function(*): ((Promise<ValidatorResponse> | ValidatorResponse))} Validator
 */

/**
 * @typedef ErrorObject
 * @property {Ref<String>} $message - Reactive error message
 * @property {Ref<Object>} $params - Params passed from withParams
 * @property {Ref<Boolean>} $pending - If validation is pending
 * @property {String} $property - State key
 * @property {String} $propertyPath - Dot notation path to state
 * @property {String} $validator - Validator name
 * @property {String} $uid - Unique identifier
 */

/**
 * @typedef ValidationResult
 * @property {Ref<Boolean>} $pending
 * @property {Ref<Boolean>} $dirty
 * @property {Ref<Boolean>} $invalid
 * @property {Ref<Boolean>} $error
 * @property {Ref<String>} $path
 * @property {Function} $touch
 * @property {Function} $reset
 * @property {ComputedRef<ErrorObject[]>} $errors
 * @property {ComputedRef<ErrorObject[]>} $silentErrors
 * @property {Function} $commit
 */

/**
 * Creates the main Validation Results object for a state tree
 * Walks the tree's top level branches
 * @param {Object<NormalizedValidator>} rules - Rules for the current state tree
 * @param {Object} model - Current state value
 * @param {String} key - Key for the current state tree
 * @param {ResultsStorage} [resultsCache] - A cache map of all the validators
 * @param {String} [path] - the current property path
 * @param {GlobalConfig} [config] - the config object
 * @param {VueInstance} instance
 * @param {ComputedRef<Object>} externalResults
 * @param {Object} siblingState
 * @return {ValidationResult | {}}
 */

function _call(body, then, direct) {
  if (direct) {
    return then ? then(body()) : body();
  }

  try {
    var result = Promise.resolve(body());
    return then ? result.then(then) : result;
  } catch (e) {
    return Promise.reject(e);
  }
}
/**
 * Collects the validation results of all nested state properties
 * @param {Object<NormalizedValidator|Function>} validations - The validation
 * @param {Object} nestedState - Current state
 * @param {String} path - Path to current property
 * @param {ResultsStorage} resultsCache - Validations cache map
 * @param {GlobalConfig} config - The config object
 * @param {VueInstance} instance - The current Vue instance
 * @param {ComputedRef<object>} nestedExternalResults - The external results for this nested collection
 * @return {Object<string, VuelidateState>}
 */


function _callIgnored(body, direct) {
  return _call(body, _empty, direct);
}

function _invoke(body, then) {
  var result = body();

  if (result && result.then) {
    return result.then(then);
  }

  return then(result);
}

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

function createValidationResults(rules, model, key, resultsCache, path, config, instance, externalResults, siblingState) {
  // collect the property keys
  const ruleKeys = Object.keys(rules);
  const cachedResult = resultsCache.get(path, rules);
  const $dirty = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(false); // state for the $rewardEarly option

  /** The last invalid state of this property */

  const $lastInvalidState = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
  /** The last time $commit was called. Used to re-trigger async calls */

  const $lastCommittedOn = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(0);

  if (cachedResult) {
    // if the rules are the same as before, use the cached results
    if (!cachedResult.$partial) return cachedResult; // remove old watchers

    cachedResult.$unwatch(); // use the `$dirty.value`, so we dont save references by accident

    $dirty.value = cachedResult.$dirty.value;
  }

  const result = {
    // restore $dirty from cache
    $dirty,
    $path: path,
    $touch: () => {
      if (!$dirty.value) $dirty.value = true;
    },
    $reset: () => {
      if ($dirty.value) $dirty.value = false;
    },
    $commit: () => {}
  };
  /**
   * If there are no validation rules, it is most likely
   * a top level state, aka root
   */

  if (!ruleKeys.length) {
    // if there are cached results, we should overwrite them with the new ones
    cachedResult && resultsCache.set(path, rules, result);
    return result;
  }

  ruleKeys.forEach(ruleKey => {
    result[ruleKey] = createValidatorResult(rules[ruleKey], model, result.$dirty, config, instance, ruleKey, key, path, siblingState, $lastInvalidState, $lastCommittedOn);
  });
  result.$externalResults = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
    if (!externalResults.value) return [];
    return [].concat(externalResults.value).map((stringError, index) => ({
      $propertyPath: path,
      $property: key,
      $validator: '$externalResults',
      $uid: `${path}-externalResult-${index}`,
      $message: stringError,
      $params: {},
      $response: null,
      $pending: false
    }));
  });
  result.$invalid = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
    const r = ruleKeys.some(ruleKey => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(result[ruleKey].$invalid)); // cache the last invalid state

    $lastInvalidState.value = r;
    return !!result.$externalResults.value.length || r;
  });
  result.$pending = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ruleKeys.some(ruleKey => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(result[ruleKey].$pending)));
  result.$error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => result.$dirty.value ? result.$pending.value || result.$invalid.value : false);
  result.$silentErrors = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ruleKeys.filter(ruleKey => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(result[ruleKey].$invalid)).map(ruleKey => {
    const res = result[ruleKey];
    return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.reactive)({
      $propertyPath: path,
      $property: key,
      $validator: ruleKey,
      $uid: `${path}-${ruleKey}`,
      $message: res.$message,
      $params: res.$params,
      $response: res.$response,
      $pending: res.$pending
    });
  }).concat(result.$externalResults.value));
  result.$errors = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => result.$dirty.value ? result.$silentErrors.value : []);

  result.$unwatch = () => ruleKeys.forEach(ruleKey => {
    result[ruleKey].$unwatch();
  });

  result.$commit = () => {
    $lastInvalidState.value = true;
    $lastCommittedOn.value = Date.now();
  };

  resultsCache.set(path, rules, result);
  return result;
}

function collectNestedValidationResults(validations, nestedState, path, resultsCache, config, instance, nestedExternalResults) {
  const nestedValidationKeys = Object.keys(validations); // if we have no state, return empty object

  if (!nestedValidationKeys.length) return {};
  return nestedValidationKeys.reduce((results, nestedKey) => {
    // build validation results for nested state
    results[nestedKey] = setValidations({
      validations: validations[nestedKey],
      state: nestedState,
      key: nestedKey,
      parentKey: path,
      resultsCache,
      globalConfig: config,
      instance,
      externalResults: nestedExternalResults
    });
    return results;
  }, {});
}
/**
 * Generates the Meta fields from the results
 * @param {ValidationResult|{}} results
 * @param {Object.<string, VuelidateState>} nestedResults
 * @param {Object.<string, ValidationResult>} childResults
 * @return {{$anyDirty: Ref<Boolean>, $error: Ref<Boolean>, $invalid: Ref<Boolean>, $errors: Ref<ErrorObject[]>, $dirty: Ref<Boolean>, $touch: Function, $reset: Function }}
 */


function createMetaFields(results, nestedResults, childResults) {
  const allResults = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => [nestedResults, childResults].filter(res => res).reduce((allRes, res) => {
    return allRes.concat(Object.values((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(res)));
  }, [])); // returns `$dirty` as true, if all children are dirty

  const $dirty = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)({
    get() {
      return results.$dirty.value || (allResults.value.length ? allResults.value.every(r => r.$dirty) : false);
    },

    set(v) {
      results.$dirty.value = v;
    }

  });
  const $silentErrors = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
    // current state level errors, fallback to empty array if root
    const modelErrors = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(results.$silentErrors) || []; // collect all nested and child $silentErrors

    const nestedErrors = allResults.value.filter(result => ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(result).$silentErrors || []).length).reduce((errors, result) => {
      return errors.concat(...result.$silentErrors);
    }, []); // merge the $silentErrors

    return modelErrors.concat(nestedErrors);
  });
  const $errors = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
    // current state level errors, fallback to empty array if root
    const modelErrors = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(results.$errors) || []; // collect all nested and child $errors

    const nestedErrors = allResults.value.filter(result => ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(result).$errors || []).length).reduce((errors, result) => {
      return errors.concat(...result.$errors);
    }, []); // merge the $errors

    return modelErrors.concat(nestedErrors);
  });
  const $invalid = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => // if any of the nested values is invalid
  allResults.value.some(r => r.$invalid) || // or if the current state is invalid
  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(results.$invalid) || // fallback to false if is root
  false);
  const $pending = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => // if any of the nested values is pending
  allResults.value.some(r => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(r.$pending)) || // if any of the current state validators is pending
  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(results.$pending) || // fallback to false if is root
  false);
  const $anyDirty = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => allResults.value.some(r => r.$dirty) || allResults.value.some(r => r.$anyDirty) || $dirty.value);
  const $error = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => $dirty.value ? $pending.value || $invalid.value : false);

  const $touch = () => {
    // call the root $touch
    results.$touch(); // call all nested level $touch

    allResults.value.forEach(result => {
      result.$touch();
    });
  };

  const $commit = () => {
    // call the root $touch
    results.$commit(); // call all nested level $touch

    allResults.value.forEach(result => {
      result.$commit();
    });
  };

  const $reset = () => {
    // reset the root $dirty state
    results.$reset(); // reset all the children $dirty states

    allResults.value.forEach(result => {
      result.$reset();
    });
  }; // Ensure that if all child and nested results are $dirty, this also becomes $dirty


  if (allResults.value.length && allResults.value.every(nr => nr.$dirty)) $touch();
  return {
    $dirty,
    $errors,
    $invalid,
    $anyDirty,
    $error,
    $pending,
    $touch,
    $reset,
    $silentErrors,
    $commit
  };
}
/**
 * @typedef VuelidateState
 * @property {WritableComputedRef<any>} $model
 * @property {ComputedRef<Boolean>} $dirty
 * @property {ComputedRef<Boolean>} $error
 * @property {ComputedRef<ErrorObject[]>} $errors
 * @property {ComputedRef<Boolean>} $invalid
 * @property {ComputedRef<Boolean>} $anyDirty
 * @property {ComputedRef<Boolean>} $pending
 * @property {Function} $touch
 * @property {Function} $reset
 * @property {String} $path
 * @property {ComputedRef<ErrorObject[]>} $silentErrors
 * @property {Function} [$validate]
 * @property {Function} [$getResultsForChild]
 * @property {Object.<string, VuelidateState>}
 */

/**
 * Main Vuelidate bootstrap function.
 * Used both for Composition API in `setup` and for Global App usage.
 * Used to collect validation state, when walking recursively down the state tree
 * @param {Object} params
 * @param {Object<NormalizedValidator|Function>} params.validations
 * @param {Object} params.state
 * @param {String} [params.key] - Current state property key. Used when being called on nested items
 * @param {String} [params.parentKey] - Parent state property key. Used when being called recursively
 * @param {Object<string, ValidationResult>} [params.childResults] - Used to collect child results.
 * @param {ResultsStorage} params.resultsCache - The cached validation results
 * @param {VueInstance} params.instance - The current Vue instance
 * @param {GlobalConfig} params.globalConfig - The validation config, passed to this setValidations instance.
 * @param {UnwrapNestedRefs<object> | Ref<Object>} params.externalResults - External validation results
 * @return {UnwrapNestedRefs<VuelidateState>}
 */


function setValidations(_ref) {
  /**
   * Executes the validators and returns the result.
   * @return {Promise<boolean>}
   */
  const $validate = _async(function () {
    if (!$dirty.value) $touch();
    return _invoke(function () {
      if (mergedConfig.$rewardEarly) {
        $commit(); // await the watchers

        return _callIgnored(vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick);
      }
    }, function () {
      // await the watchers
      return _call(vue_demi__WEBPACK_IMPORTED_MODULE_0__.nextTick, function () {
        return new Promise(resolve => {
          // return whether it is valid or not
          if (!$pending.value) return resolve(!$invalid.value);
          const unwatch = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)($pending, () => {
            resolve(!$invalid.value);
            unwatch();
          });
        });
      });
    });
  });
  /**
   * Returns a child component's results, based on registration name
   * @param {string} key
   * @return {VuelidateState}
   */


  let {
    validations,
    state,
    key,
    parentKey,
    childResults,
    resultsCache,
    globalConfig = {},
    instance,
    externalResults
  } = _ref;
  const path = parentKey ? `${parentKey}.${key}` : key; // Sort out the validation object into:
  // â€“ rules = validators for current state tree fragment
  // â€” nestedValidators = nested state fragments keys that might contain more validators
  // â€“ config = configuration properties that affect this state fragment

  const {
    rules,
    nestedValidators,
    config
  } = sortValidations(validations);
  const mergedConfig = Object.assign({}, globalConfig, config); // create protected state for cases when the state branch does not exist yet.
  // This protects when using the OptionsAPI as the data is bound after the setup method

  const nestedState = key ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
    const s = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(state);
    return s ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(s[key]) : undefined;
  }) : state; // cache the external results, so we can revert back to them

  const cachedExternalResults = Object.assign({}, (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(externalResults) || {});
  const nestedExternalResults = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
    const results = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(externalResults);
    if (!key) return results;
    return results ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(results[key]) : undefined;
  }); // Use rules for the current state fragment and validate it

  const results = createValidationResults(rules, nestedState, key, resultsCache, path, mergedConfig, instance, nestedExternalResults, state); // Use nested keys to repeat the process
  // *WARN*: This is recursive

  const nestedResults = collectNestedValidationResults(nestedValidators, nestedState, path, resultsCache, mergedConfig, instance, nestedExternalResults); // Collect and merge this level validation results
  // with all nested validation results

  const {
    $dirty,
    $errors,
    $invalid,
    $anyDirty,
    $error,
    $pending,
    $touch,
    $reset,
    $silentErrors,
    $commit
  } = createMetaFields(results, nestedResults, childResults);
  /**
   * If we have no `key`, this is the top level state
   * We dont need `$model` there.
   */

  const $model = key ? (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)({
    get: () => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(nestedState),
    set: val => {
      $dirty.value = true;
      const s = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(state);
      const external = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(externalResults);

      if (external) {
        external[key] = cachedExternalResults[key];
      }

      if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(s[key])) {
        s[key].value = val;
      } else {
        s[key] = val;
      }
    }
  }) : null;

  if (key && mergedConfig.$autoDirty) {
    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(nestedState, () => {
      if (!$dirty.value) $touch();
      const external = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(externalResults);

      if (external) {
        external[key] = cachedExternalResults[key];
      }
    }, {
      flush: 'sync'
    });
  }

  function $getResultsForChild(key) {
    return (childResults.value || {})[key];
  }

  function $clearExternalResults() {
    if ((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(externalResults)) {
      externalResults.value = cachedExternalResults;
    } else {
      // if the external results state was empty, we need to delete every property, one by one
      if (Object.keys(cachedExternalResults).length === 0) {
        Object.keys(externalResults).forEach(k => {
          delete externalResults[k];
        });
      } else {
        // state was not empty, so we just assign it back into the current state
        Object.assign(externalResults, cachedExternalResults);
      }
    }
  }

  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.reactive)(Object.assign({}, results, {
    // NOTE: The order here is very important, since we want to override
    // some of the *results* meta fields with the collective version of it
    // that includes the results of nested state validation results
    $model,
    $dirty,
    $error,
    $errors,
    $invalid,
    $anyDirty,
    $pending,
    $touch,
    $reset,
    $path: path || ROOT_PATH,
    $silentErrors,
    $validate,
    $commit
  }, childResults && {
    $getResultsForChild,
    $clearExternalResults
  }, nestedResults));
}

class ResultsStorage {
  constructor() {
    this.storage = new Map();
  }
  /**
   * Stores a validation result, and its rules by its path
   * @param {String} path
   * @param {Object<NormalizedValidator>} rules
   * @param {ValidationResult} result
   */


  set(path, rules, result) {
    this.storage.set(path, {
      rules,
      result
    });
  }
  /**
   * Check if the stored `results` for the provided `path` have the same `rules` compared to 'storedRules'
   * @param {String} path
   * @param {Object<NormalizedValidator>} rules
   * @param {Object<NormalizedValidator>} storedRules
   * @return {Boolean}
   */


  checkRulesValidity(path, rules, storedRules) {
    const storedRulesKeys = Object.keys(storedRules);
    const newRulesKeys = Object.keys(rules);
    if (newRulesKeys.length !== storedRulesKeys.length) return false;
    const hasAllValidators = newRulesKeys.every(ruleKey => storedRulesKeys.includes(ruleKey));
    if (!hasAllValidators) return false;
    return newRulesKeys.every(ruleKey => {
      if (!rules[ruleKey].$params) return true;
      return Object.keys(rules[ruleKey].$params).every(paramKey => {
        // make sure to unwrap before comparing
        return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(storedRules[ruleKey].$params[paramKey]) === (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(rules[ruleKey].$params[paramKey]);
      });
    });
  }
  /**
   * Returns the matched result if catche is valid
   * @param {String} path
   * @param {Object<NormalizedValidator>} rules
   * @return {{$partial: boolean, $dirty: Ref<Boolean>, $unwatch: function}|undefined|ValidationResult}
   */


  get(path, rules) {
    const storedRuleResultPair = this.storage.get(path);
    if (!storedRuleResultPair) return undefined;
    const {
      rules: storedRules,
      result
    } = storedRuleResultPair;
    const isValidCache = this.checkRulesValidity(path, rules, storedRules);
    const $unwatch = result.$unwatch ? result.$unwatch : () => ({});
    if (!isValidCache) return {
      $dirty: result.$dirty,
      $partial: true,
      $unwatch
    };
    return result;
  }

}

const CollectFlag = {
  COLLECT_ALL: true,
  COLLECT_NONE: false
};
const VuelidateInjectChildResults = Symbol('vuelidate#injectChiildResults');
const VuelidateRemoveChildResults = Symbol('vuelidate#removeChiildResults');
/**
 * Create helpers to collect validation state from child components
 * @param {Object} params
 * @param {String | Number | Boolean} params.$scope - Parent component scope
 * @return {{sendValidationResultsToParent: function[], childResults: ComputedRef<Object>, removeValidationResultsFromParent: function[]}}
 */

function nestedValidations(_ref) {
  let {
    $scope,
    instance
  } = _ref;
  const childResultsRaw = {};
  const childResultsKeys = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)([]);
  const childResults = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => childResultsKeys.value.reduce((results, key) => {
    results[key] = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(childResultsRaw[key]);
    return results;
  }, {}));
  /**
   * Allows children to send validation data up to their parent.
   * @param {Object} results - the results
   * @param {Object} args
   * @param {String} args.$registerAs - the $registeredAs key
   * @param {String | Number | Boolean} args.$scope - the $scope key
   */

  function injectChildResultsIntoParent(results, _ref2) {
    let {
      $registerAs: key,
      $scope: childScope,
      $stopPropagation
    } = _ref2;
    if ($stopPropagation || $scope === CollectFlag.COLLECT_NONE || childScope === CollectFlag.COLLECT_NONE || $scope !== CollectFlag.COLLECT_ALL && $scope !== childScope) return;
    childResultsRaw[key] = results;
    childResultsKeys.value.push(key);
  } // combine with other `injectChildResultsIntoParent` from vuelidate instances in this Vue component instance


  instance.__vuelidateInjectInstances = [].concat(instance.__vuelidateInjectInstances || [], injectChildResultsIntoParent);
  /**
   * Allows children to remove the validation data from their parent, before getting destroyed.
   * @param {String} key - the registeredAs key
   */

  function removeChildResultsFromParent(key) {
    // remove the key
    childResultsKeys.value = childResultsKeys.value.filter(childKey => childKey !== key); // remove the stored data for the key

    delete childResultsRaw[key];
  } // combine with other `removeChildResultsFromParent` from vuelidate instances in this Vue component instance


  instance.__vuelidateRemoveInstances = [].concat(instance.__vuelidateRemoveInstances || [], removeChildResultsFromParent); // inject the `injectChildResultsIntoParent` method, into the current scope

  const sendValidationResultsToParent = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.inject)(VuelidateInjectChildResults, []); // provide to all of its children the send results to parent function

  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.provide)(VuelidateInjectChildResults, instance.__vuelidateInjectInstances);
  const removeValidationResultsFromParent = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.inject)(VuelidateRemoveChildResults, []); // provide to all of its children the remove results  function

  (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.provide)(VuelidateRemoveChildResults, instance.__vuelidateRemoveInstances);
  return {
    childResults,
    sendValidationResultsToParent,
    removeValidationResultsFromParent
  };
}

/**
 * Helper proxy for instance property access. It makes every reference
 * reactive for the validation function
 * @param target
 * @return {*|ComputedRef<*>}
 */

function ComputedProxyFactory(target) {
  return new Proxy(target, {
    get(target, prop) {
      return typeof target[prop] === 'object' ? ComputedProxyFactory(target[prop]) : (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => target[prop]);
    }

  });
}

/**
 * @typedef GlobalConfig
 * @property {String} [$registerAs] - Config Object
 * @property {String | Number | Symbol} [$scope] - A scope to limit child component registration
 * @property {Boolean} [$stopPropagation] - Tells a Vue component to stop sending its results up to the parent
 * @property {Ref<Object>} [$externalResults] - External error messages, like from server validation.
 * @property {Boolean} [$autoDirty] - Should the form watch for state changed, and automatically set `$dirty` to true.
 * @property {Boolean} [$lazy] - Should the validations be lazy, and run only after they are dirty
 * @property {Boolean} [$rewardEarly] - Once valid, re-runs property validators only on manual calls of $commit
 */

/**
 * Composition API compatible Vuelidate
 * Use inside the `setup` lifecycle hook
 * @param {Object | GlobalConfig} [validations] - Validations Object or the globalConfig.
 * @param {Object} [state] - State object - required if `validations` is a validation object.
 * @param {GlobalConfig} [globalConfig] - Config Object
 * @return {ComputedRef<*>}
 */

function useVuelidate(validations, state) {
  let globalConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // if we pass only one argument, its most probably the globalConfig.
  // This use case is so parents can just collect results of child forms.
  if (arguments.length === 1) {
    globalConfig = validations;
    validations = undefined;
    state = undefined;
  }

  let {
    $registerAs,
    $scope = CollectFlag.COLLECT_ALL,
    $stopPropagation,
    $externalResults,
    currentVueInstance
  } = globalConfig;
  const instance = currentVueInstance || (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  const componentOptions = instance ? vue_demi__WEBPACK_IMPORTED_MODULE_0__.isVue3 ? instance.type : instance.proxy.$options : {}; // if there is no registration name, add one.

  if (!$registerAs && instance) {
    // NOTE:
    // ._uid // Vue 2.x Composition-API plugin
    // .uid // Vue 3.0
    const uid = instance.uid || instance._uid;
    $registerAs = `_vuelidate_${uid}`;
  }

  const validationResults = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)({});
  const resultsCache = new ResultsStorage();
  const {
    childResults,
    sendValidationResultsToParent,
    removeValidationResultsFromParent
  } = instance ? nestedValidations({
    $scope,
    instance
  }) : {
    childResults: (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)({})
  }; // Options API

  if (!validations && componentOptions.validations) {
    const rules = componentOptions.validations;
    state = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount)(() => {
      // Delay binding state to validations defined with the Options API until mounting, when the data
      // has been attached to the component instance. From that point on it will be reactive.
      state.value = instance.proxy;
      (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(() => isFunction(rules) ? rules.call(state.value, new ComputedProxyFactory(state.value)) : rules, validations => {
        validationResults.value = setValidations({
          validations,
          state,
          childResults,
          resultsCache,
          globalConfig,
          instance: instance.proxy,
          externalResults: $externalResults || instance.proxy.vuelidateExternalResults
        });
      }, {
        immediate: true
      });
    });
    globalConfig = componentOptions.validationsConfig || globalConfig;
  } else {
    const validationsWatchTarget = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.isRef)(validations) || isProxy(validations) ? validations // wrap plain objects in a reactive, so we can track changes if they have computed in them.
    : (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.reactive)(validations || {});
    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(validationsWatchTarget, newValidationRules => {
      validationResults.value = setValidations({
        validations: newValidationRules,
        state,
        childResults,
        resultsCache,
        globalConfig,
        instance: instance ? instance.proxy : {},
        externalResults: $externalResults
      });
    }, {
      immediate: true
    });
  }

  if (instance) {
    // send all the data to the parent when the function is invoked inside setup.
    sendValidationResultsToParent.forEach(f => f(validationResults, {
      $registerAs,
      $scope,
      $stopPropagation
    })); // before this component is destroyed, remove all the data from the parent.

    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount)(() => removeValidationResultsFromParent.forEach(f => f($registerAs)));
  }

  return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
    return Object.assign({}, (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(validationResults.value), childResults.value);
  });
}




/***/ }),

/***/ "./node_modules/@vuelidate/validators/dist/index.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vuelidate/validators/dist/index.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "alpha": () => (/* binding */ alpha),
/* harmony export */   "alphaNum": () => (/* binding */ alphaNum),
/* harmony export */   "and": () => (/* binding */ and),
/* harmony export */   "between": () => (/* binding */ between),
/* harmony export */   "createI18nMessage": () => (/* binding */ createI18nMessage),
/* harmony export */   "decimal": () => (/* binding */ decimal),
/* harmony export */   "email": () => (/* binding */ email),
/* harmony export */   "helpers": () => (/* binding */ common),
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "ipAddress": () => (/* binding */ ipAddress),
/* harmony export */   "macAddress": () => (/* binding */ macAddress),
/* harmony export */   "maxLength": () => (/* binding */ maxLength),
/* harmony export */   "maxValue": () => (/* binding */ maxValue),
/* harmony export */   "minLength": () => (/* binding */ minLength),
/* harmony export */   "minValue": () => (/* binding */ minValue),
/* harmony export */   "not": () => (/* binding */ not),
/* harmony export */   "numeric": () => (/* binding */ numeric),
/* harmony export */   "or": () => (/* binding */ or),
/* harmony export */   "required": () => (/* binding */ required),
/* harmony export */   "requiredIf": () => (/* binding */ requiredIf),
/* harmony export */   "requiredUnless": () => (/* binding */ requiredUnless),
/* harmony export */   "sameAs": () => (/* binding */ sameAs),
/* harmony export */   "url": () => (/* binding */ url)
/* harmony export */ });
/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-demi */ "./node_modules/@vuelidate/validators/node_modules/vue-demi/lib/index.mjs");


function isFunction(val) {
  return typeof val === 'function';
}
function isObject(o) {
  return o !== null && typeof o === 'object' && !Array.isArray(o);
}
/**
 * Returns a standard ValidatorObject
 * Wraps a plain function into a ValidatorObject
 * @param {NormalizedValidator|Function} validator
 * @return {NormalizedValidator}
 */

function normalizeValidatorObject(validator) {
  return isFunction(validator.$validator) ? Object.assign({}, validator) : {
    $validator: validator
  };
}
function isPromise(object) {
  return isObject(object) && isFunction(object.then);
}
/**
 * Unwraps a ValidatorResponse object, into a boolean.
 * @param {ValidatorResponse} result
 * @return {boolean}
 */

function unwrapValidatorResponse(result) {
  if (typeof result === 'object') return result.$valid;
  return result;
}
/**
 * Unwraps a `NormalizedValidator` object, returning its validator function.
 * @param {NormalizedValidator | Function} validator
 * @return {function}
 */

function unwrapNormalizedValidator(validator) {
  return validator.$validator || validator;
}

/**
 * Allows attaching parameters to a validator
 * @param {Object} $params
 * @param {NormalizedValidator|Function} $validator
 * @return {NormalizedValidator}
 */

function withParams($params, $validator) {
  if (!isObject($params)) throw new Error(`[@vuelidate/validators]: First parameter to "withParams" should be an object, provided ${typeof $params}`);
  if (!isObject($validator) && !isFunction($validator)) throw new Error(`[@vuelidate/validators]: Validator must be a function or object with $validator parameter`);
  const validatorObj = normalizeValidatorObject($validator);
  validatorObj.$params = Object.assign({}, validatorObj.$params || {}, $params);
  return validatorObj;
}

/**
 * @callback MessageCallback
 * @param {Object} params
 * @return String
 */

/**
 * Attaches a message to a validator
 * @param {MessageCallback | String} $message
 * @param {NormalizedValidator|Function} $validator
 * @return {NormalizedValidator}
 */

function withMessage($message, $validator) {
  if (!isFunction($message) && typeof (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)($message) !== 'string') throw new Error(`[@vuelidate/validators]: First parameter to "withMessage" should be string or a function returning a string, provided ${typeof $message}`);
  if (!isObject($validator) && !isFunction($validator)) throw new Error(`[@vuelidate/validators]: Validator must be a function or object with $validator parameter`);
  const validatorObj = normalizeValidatorObject($validator);
  validatorObj.$message = $message;
  return validatorObj;
}

/**
 * @typedef {function(*): Promise<boolean|ValidatorResponse>} asyncValidator
 */

/**
 * @typedef {Ref<*>[]|function(*): *} watchTargets
 */

/**
 * Wraps validators that returns a Promise.
 * @param {asyncValidator} $validator
 * @param {watchTargets} $watchTargets
 * @return {{$async: boolean, $validator: asyncValidator, $watchTargets: watchTargets}}
 */

function withAsync($validator, $watchTargets = []) {
  const validatorObj = normalizeValidatorObject($validator);
  return Object.assign({}, validatorObj, {
    $async: true,
    $watchTargets
  });
}

function forEach(validators) {
  return {
    $validator(collection, ...others) {
      // go over the collection. It can be a ref as well.
      return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(collection).reduce((previous, collectionItem) => {
        // go over each property
        const collectionEntryResult = Object.entries(collectionItem).reduce((all, [property, $model]) => {
          // get the validators for this property
          const innerValidators = validators[property] || {}; // go over each validator and run it

          const propertyResult = Object.entries(innerValidators).reduce((all, [validatorName, currentValidator]) => {
            // extract the validator. Supports simple and extended validators.
            const validatorFunction = unwrapNormalizedValidator(currentValidator); // Call the validator, passing the VM as this, the value, current iterated object and the rest.

            const $response = validatorFunction.call(this, $model, collectionItem, ...others); // extract the valid from the result

            const $valid = unwrapValidatorResponse($response); // store the entire response for later

            all.$data[validatorName] = $response;
            all.$data.$invalid = !$valid || !!all.$data.$invalid;
            all.$data.$error = all.$data.$invalid; // if not valid, get the $message

            if (!$valid) {
              let $message = currentValidator.$message || '';
              const $params = currentValidator.$params || {}; // If $message is a function, we call it with the appropriate parameters

              if (typeof $message === 'function') {
                $message = $message({
                  $pending: false,
                  $invalid: !$valid,
                  $params,
                  $model,
                  $response
                });
              } // save the error object


              all.$errors.push({
                $property: property,
                $message,
                $params,
                $response,
                $model,
                $pending: false,
                $validator: validatorName
              });
            }

            return {
              $valid: all.$valid && $valid,
              $data: all.$data,
              $errors: all.$errors
            };
          }, {
            $valid: true,
            $data: {},
            $errors: []
          });
          all.$data[property] = propertyResult.$data;
          all.$errors[property] = propertyResult.$errors;
          return {
            $valid: all.$valid && propertyResult.$valid,
            $data: all.$data,
            $errors: all.$errors
          };
        }, {
          $valid: true,
          $data: {},
          $errors: {}
        });
        return {
          $valid: previous.$valid && collectionEntryResult.$valid,
          $data: previous.$data.concat(collectionEntryResult.$data),
          $errors: previous.$errors.concat(collectionEntryResult.$errors)
        };
      }, {
        $valid: true,
        $data: [],
        $errors: []
      });
    },

    // collect all the validation errors into a 2 dimensional array, for each entry in the collection, you have an array of error messages.
    $message: ({
      $response
    }) => $response ? $response.$errors.map(context => {
      return Object.values(context).map(errors => errors.map(error => error.$message)).reduce((a, b) => a.concat(b), []);
    }) : []
  };
}

// "required" core, used in almost every validator to allow empty values
const req = value => {
  value = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(value);
  if (Array.isArray(value)) return !!value.length;

  if (value === undefined || value === null) {
    return false;
  }

  if (value === false) {
    return true;
  }

  if (value instanceof Date) {
    // invalid date won't pass
    return !isNaN(value.getTime());
  }

  if (typeof value === 'object') {
    for (let _ in value) return true;

    return false;
  }

  return !!String(value).length;
};
/**
 * Returns the length of an arbitrary value
 * @param {Array|Object|String} value
 * @return {number}
 */

const len = value => {
  value = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(value);
  if (Array.isArray(value)) return value.length;

  if (typeof value === 'object') {
    return Object.keys(value).length;
  }

  return String(value).length;
};
/**
 * Regex based validator template
 * @param {RegExp} expr
 * @return {function(*=): boolean}
 */

function regex(expr) {
  return value => {
    value = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(value);
    return !req(value) || expr.test(value);
  };
}

var common = /*#__PURE__*/Object.freeze({
  __proto__: null,
  withParams: withParams,
  withMessage: withMessage,
  withAsync: withAsync,
  forEach: forEach,
  req: req,
  len: len,
  regex: regex,
  unwrap: vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref,
  unwrapNormalizedValidator: unwrapNormalizedValidator,
  unwrapValidatorResponse: unwrapValidatorResponse,
  normalizeValidatorObject: normalizeValidatorObject
});

var alpha$1 = regex(/^[a-zA-Z]*$/);

/**
 * Validate if value is alphabetical string.
 * @type {NormalizedValidator}
 */

var alpha = {
  $validator: alpha$1,
  $message: 'The value is not alphabetical',
  $params: {
    type: 'alpha'
  }
};

var alphaNum$1 = regex(/^[a-zA-Z0-9]*$/);

/**
 * Validate if value is alpha-numeric string.
 * @type {NormalizedValidator}
 */

var alphaNum = {
  $validator: alphaNum$1,
  $message: 'The value must be alpha-numeric',
  $params: {
    type: 'alphaNum'
  }
};

var numeric$1 = regex(/^\d*(\.\d+)?$/);

/**
 * Check whether a value is numeric.
 * @type NormalizedValidator
 */

var numeric = {
  $validator: numeric$1,
  $message: 'Value must be numeric',
  $params: {
    type: 'numeric'
  }
};

/**
 * Check if a numeric value is between two values.
 * @param {Ref<Number> | Number} min
 * @param {Ref<Number> | Number} max
 * @return {function(*=): boolean}
 */

function between$1 (min, max) {
  return value => !req(value) || (!/\s/.test(value) || value instanceof Date) && +(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(min) <= +value && +(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(max) >= +value;
}

/**
 * Checks if a value is between two values.
 * @param {Ref<Number> | Number} min
 * @param {Ref<Number> | Number} max
 * @return {NormalizedValidator}
 */

function between (min, max) {
  return {
    $validator: between$1(min, max),
    $message: ({
      $params
    }) => `The value must be between ${$params.min} and ${$params.max}`,
    $params: {
      min,
      max,
      type: 'between'
    }
  };
}

const emailRegex = /^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
var email$1 = regex(emailRegex);

/**
 * Validate if value is an email.
 * @type {NormalizedValidator}
 */

var email = {
  $validator: email$1,
  $message: 'Value is not a valid email address',
  $params: {
    type: 'email'
  }
};

/**
 * Check if a string is an IP Address
 * @param {String} value
 * @returns {boolean}
 */

function ipAddress$1 (value) {
  if (!req(value)) {
    return true;
  }

  if (typeof value !== 'string') {
    return false;
  }

  const nibbles = value.split('.');
  return nibbles.length === 4 && nibbles.every(nibbleValid);
}

const nibbleValid = nibble => {
  if (nibble.length > 3 || nibble.length === 0) {
    return false;
  }

  if (nibble[0] === '0' && nibble !== '0') {
    return false;
  }

  if (!nibble.match(/^\d+$/)) {
    return false;
  }

  const numeric = +nibble | 0;
  return numeric >= 0 && numeric <= 255;
};

/**
 * Validate if value is an ipAddress string.
 * @type {NormalizedValidator}
 */

var ipAddress = {
  $validator: ipAddress$1,
  $message: 'The value is not a valid IP address',
  $params: {
    type: 'ipAddress'
  }
};

/**
 * Check if value is a properly formatted Mac Address.
 * @param {String | Ref<String>} [separator]
 * @returns {function(*): boolean}
 */

function macAddress$1 (separator = ':') {
  return value => {
    separator = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(separator);

    if (!req(value)) {
      return true;
    }

    if (typeof value !== 'string') {
      return false;
    }

    const parts = typeof separator === 'string' && separator !== '' ? value.split(separator) : value.length === 12 || value.length === 16 ? value.match(/.{2}/g) : null;
    return parts !== null && (parts.length === 6 || parts.length === 8) && parts.every(hexValid);
  };
}

const hexValid = hex => hex.toLowerCase().match(/^[0-9a-f]{2}$/);

/**
 * Validate if value is a valid Mac Address string.
 * @returns {NormalizedValidator}
 */

function macAddress (separator) {
  return {
    $validator: macAddress$1(separator),
    $message: 'The value is not a valid MAC Address',
    $params: {
      type: 'macAddress'
    }
  };
}

/**
 * Check if provided value has a maximum length
 * @param {Number | Ref<Number>} length
 * @returns {function(Array|Object|String): boolean}
 */

function maxLength$1 (length) {
  return value => !req(value) || len(value) <= (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(length);
}

/**
 * Validate the max length of a string.
 * @param {Number} max
 * @return {NormalizedValidator}
 */

function maxLength (max) {
  return {
    $validator: maxLength$1(max),
    $message: ({
      $params
    }) => `The maximum length allowed is ${$params.max}`,
    $params: {
      max,
      type: 'maxLength'
    }
  };
}

/**
 * Check if value is above a threshold.
 * @param {Number | Ref<Number>} length
 * @returns {function(Array|Object|String): boolean}
 */

function minLength$1 (length) {
  return value => !req(value) || len(value) >= (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(length);
}

/**
 * Check if value is above a threshold.
 * @param {Number | Ref<Number>} min
 * @returns {NormalizedValidator}
 */

function minLength (min) {
  return {
    $validator: minLength$1(min),
    $message: ({
      $params
    }) => `This field should be at least ${$params.min} long`,
    $params: {
      min,
      type: 'minLength'
    }
  };
}

/**
 * Validates if a value is empty.
 * @param {String | Array | Date | Object} value
 * @returns {boolean}
 */

function required$1 (value) {
  if (typeof value === 'string') {
    value = value.trim();
  }

  return req(value);
}

/**
 * Check if a value is empty or not.
 * @type {NormalizedValidator}
 */

var required = {
  $validator: required$1,
  $message: 'Value is required',
  $params: {
    type: 'required'
  }
};

const validate$1 = (prop, val) => prop ? req(val) : true;
/**
 * Returns required if the passed property is truthy
 * @param {Boolean | String | function(any): Boolean | Ref<string | boolean>} propOrFunction
 * @return {function(value: *, parentVM: object): Boolean}
 */


function requiredIf$1(propOrFunction) {
  return function (value, parentVM) {
    if (typeof propOrFunction !== 'function') {
      return validate$1((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(propOrFunction), value);
    }

    const result = propOrFunction.call(this, value, parentVM);
    return validate$1(result, value);
  };
}

/**
 * Returns required if the passed property is truthy
 * @param {Boolean | String | function(): (Boolean | Promise<boolean>)} prop
 * @return {NormalizedValidator}
 */

function requiredIf (prop) {
  return {
    $validator: requiredIf$1(prop),
    $message: 'The value is required',
    $params: {
      type: 'requiredIf',
      prop
    }
  };
}

const validate = (prop, val) => !prop ? req(val) : true;
/**
 * Returns required if the passed property is falsy.
 * @param {Boolean | String | function(any): Boolean | Ref<string | boolean>} propOrFunction
 * @return {function(value: *, parentVM: object): Boolean}
 */


function requiredUnless$1(propOrFunction) {
  return function (value, parentVM) {
    if (typeof propOrFunction !== 'function') {
      return validate((0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(propOrFunction), value);
    }

    const result = propOrFunction.call(this, value, parentVM);
    return validate(result, value);
  };
}

/**
 * Returns required unless the passed property is truthy
 * @param {Boolean | String | function(): (Boolean | Promise<boolean>)} prop
 * @return {NormalizedValidator}
 */

function requiredUnless (prop) {
  return {
    $validator: requiredUnless$1(prop),
    $message: 'The value is required',
    $params: {
      type: 'requiredUnless',
      prop
    }
  };
}

/**
 * Check if two values are identical.
 * @param {*} equalTo
 * @return {function(*=): boolean}
 */

function sameAs$1 (equalTo) {
  return value => (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(value) === (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(equalTo);
}

/**
 * Check if two values are identical
 * @param {*} equalTo
 * @param {String} [otherName]
 * @return {NormalizedValidator}
 */

function sameAs (equalTo, otherName = 'other') {
  return {
    $validator: sameAs$1(equalTo),
    $message: ({
      $params
    }) => `The value must be equal to the ${otherName} value`,
    $params: {
      equalTo,
      otherName,
      type: 'sameAs'
    }
  };
}

/**
 * Regex taken from {@link https://gist.github.com/dperini/729294}
 */

const urlRegex = /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i;
var url$1 = regex(urlRegex);

/**
 * Check if a value is a url
 * @type {NormalizedValidator}
 */

var url = {
  $validator: url$1,
  $message: 'The value is not a valid URL address',
  $params: {
    type: 'url'
  }
};

function _await$1(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function syncOr(validators) {
  return function (...args) {
    return validators.reduce((valid, fn) => {
      if (unwrapValidatorResponse(valid)) return valid;
      return unwrapNormalizedValidator(fn).apply(this, args);
    }, false);
  };
}

function asyncOr(validators) {
  return function (...args) {
    const _this = this;

    return validators.reduce(function (valid, fn) {
      return _await$1(valid, function (r) {
        return unwrapValidatorResponse(r) ? r : unwrapNormalizedValidator(fn).apply(_this, args);
      });
    }, Promise.resolve(false));
  };
}
/**
 * Returns true when one of the provided functions returns true.
 * @param {...(NormalizedValidator|Function)} validators
 * @return {{$validator: function(...[*]=): (boolean | Promise<boolean>), $async: boolean, $watchTargets: any[]}}
 */


function or$1(...validators) {
  const $async = validators.some(v => v.$async);
  const $watchTargets = validators.reduce((all, v) => {
    if (!v.$watchTargets) return all;
    return all.concat(v.$watchTargets);
  }, []);

  let $validator = () => false;

  if (validators.length) $validator = $async ? asyncOr(validators) : syncOr(validators);
  return {
    $async,
    $validator,
    $watchTargets
  };
}

/**
 * Returns true when one of the provided functions returns true.
 * @param {...(NormalizedValidator|Function)} validators
 * @return {NormalizedValidator}
 */

function or (...validators) {
  return withParams({
    type: 'or'
  }, withMessage('The value does not match any of the provided validators', or$1(...validators)));
}

function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}
/**
 *
 * @param validators
 * @return {function(...[*]=): Promise<boolean>}
 */


function syncAnd(validators) {
  return function (...args) {
    return validators.reduce((valid, fn) => {
      if (!unwrapValidatorResponse(valid)) return valid;
      return unwrapNormalizedValidator(fn).apply(this, args);
    }, true);
  };
}

function asyncAnd(validators) {
  return function (...args) {
    const _this = this;

    return validators.reduce(function (valid, fn) {
      return _await(valid, function (r) {
        return unwrapValidatorResponse(r) ? unwrapNormalizedValidator(fn).apply(_this, args) : r;
      });
    }, Promise.resolve(true));
  };
}
/**
 * Returns true when all validators are truthy
 * @param {...(NormalizedValidator | Function)} validators
 * @return {{$validator: function(...[*]=): (boolean | Promise<boolean>), $async: boolean, $watchTargets: any[]}}
 */


function and$1(...validators) {
  const $async = validators.some(v => v.$async);
  const $watchTargets = validators.reduce((all, v) => {
    if (!v.$watchTargets) return all;
    return all.concat(v.$watchTargets);
  }, []);

  let $validator = () => false;

  if (validators.length) $validator = $async ? asyncAnd(validators) : syncAnd(validators);
  return {
    $async,
    $validator,
    $watchTargets
  };
}

/**
 * Validate if all validators match.
 * @param {...*} validators
 * @returns {NormalizedValidator}
 */

function and (...validators) {
  return withParams({
    type: 'and'
  }, withMessage('The value does not match all of the provided validators', and$1(...validators)));
}

/**
 * Swaps the result of a value
 * @param {NormalizedValidator|Function} validator
 * @returns {function(*=, *=): boolean}
 */

function not$1 (validator) {
  return function (value, vm) {
    if (!req(value)) return true;
    const response = unwrapNormalizedValidator(validator).call(this, value, vm);
    if (!isPromise(response)) return !unwrapValidatorResponse(response);
    return response.then(r => !unwrapValidatorResponse(r));
  };
}

/**
 * Swaps the result of a value
 * @param {NormalizedValidator|Function} validator
 * @returns {NormalizedValidator}
 */

function not (validator) {
  return {
    $validator: not$1(validator),
    $message: `The value does not match the provided validator`,
    $params: {
      type: 'not'
    }
  };
}

/**
 * Check if a value is above a threshold.
 * @param {String | Number | Ref<Number> | Ref<String>} min
 * @returns {function(*=): boolean}
 */

function minValue$1 (min) {
  return value => !req(value) || (!/\s/.test(value) || value instanceof Date) && +value >= +(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(min);
}

/**
 * Check if a value is above a threshold.
 * @param {String | Number | Ref<Number> | Ref<String>} min
 * @returns {NormalizedValidator}
 */

function minValue (min) {
  return {
    $validator: minValue$1(min),
    $message: ({
      $params
    }) => `The minimum value allowed is ${$params.min}`,
    $params: {
      min,
      type: 'minValue'
    }
  };
}

/**
 * Check if value is below a threshold.
 * @param {Number | Ref<Number> | Ref<String>} max
 * @returns {function(*=): boolean}
 */

function maxValue$1 (max) {
  return value => !req(value) || (!/\s/.test(value) || value instanceof Date) && +value <= +(0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.unref)(max);
}

/**
 * Check if value is below a threshold.
 * @param {Number | Ref<Number> | Ref<String>} max
 * @return {NormalizedValidator}
 */

var maxValue = (max => ({
  $validator: maxValue$1(max),
  $message: ({
    $params
  }) => `The maximum value is ${$params.max}`,
  $params: {
    max,
    type: 'maxValue'
  }
}));

// ^-[0-9]+$ - only for negative integer (minus sign without at least 1 digit is not a number)

var integer$1 = regex(/(^[0-9]*$)|(^-[0-9]+$)/);

/**
 * Validate if value is integer.
 * @type {NormalizedValidator}
 */

var integer = {
  $validator: integer$1,
  $message: 'Value is not an integer',
  $params: {
    type: 'integer'
  }
};

var decimal$1 = regex(/^[-]?\d*(\.\d+)?$/);

/**
 * Validate if value is decimal number.
 * @type {NormalizedValidator}
 */

var decimal = {
  $validator: decimal$1,
  $message: 'Value must be decimal',
  $params: {
    type: 'decimal'
  }
};

/**
 * Creates a translatable version of `withMessage` helper.
 * @param {function} t - the translation function of your choice
 * @param {function} [messagePath] - a function to generate the message path, passed to `t` for each message. By default it is `validations.${$validator}`
 * @param {function} [messageParams] - a function to augment the params, passed to `t` for each message.
 */

function createI18nMessage({
  t,
  messagePath = ({
    $validator
  }) => `validations.${$validator}`,
  messageParams = params => params
}) {
  return function withI18nMessage(validator, {
    withArguments = false,
    messagePath: localMessagePath = messagePath,
    messageParams: localMessageParams = messageParams
  } = {}) {
    function message(props) {
      return t(localMessagePath(props), localMessageParams(Object.assign({
        model: props.$model,
        property: props.$property,
        pending: props.$pending,
        invalid: props.$invalid,
        response: props.$response,
        validator: props.$validator,
        propertyPath: props.$propertyPath
      }, props.$params)));
    }

    if (withArguments && typeof validator === 'function') {
      return (...args) => withMessage(message, validator(...args));
    }

    return withMessage(message, validator);
  };
}




/***/ }),

/***/ "./node_modules/@vuelidate/core/node_modules/vue-demi/lib/index.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@vuelidate/core/node_modules/vue-demi/lib/index.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "del": () => (/* binding */ del),
/* harmony export */   "BaseTransition": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "VueElement": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "compile": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.compile),
/* harmony export */   "computed": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Vue": () => (/* reexport module object */ vue__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "Vue2": () => (/* binding */ Vue2),
/* harmony export */   "isVue2": () => (/* binding */ isVue2),
/* harmony export */   "isVue3": () => (/* binding */ isVue3),
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");


var isVue2 = false
var isVue3 = true
var Vue2 = undefined

function install() {}

function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  target[key] = val
  return val
}

function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1)
    return
  }
  delete target[key]
}





/***/ }),

/***/ "./node_modules/@vuelidate/validators/node_modules/vue-demi/lib/index.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@vuelidate/validators/node_modules/vue-demi/lib/index.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "set": () => (/* binding */ set),
/* harmony export */   "del": () => (/* binding */ del),
/* harmony export */   "BaseTransition": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "EffectScope": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   "Fragment": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   "Static": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "VueElement": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "compile": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.compile),
/* harmony export */   "computed": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   "createElementVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineCustomElement": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   "defineEmits": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   "defineExpose": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   "defineProps": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "effect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   "effectScope": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   "h": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   "inject": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isMemoSame": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   "isProxy": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   "isVNode": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeDefaults": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   "mergeProps": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "normalizeClass": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   "onActivated": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "stop": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useAttrs": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   "useCssModule": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useSlots": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "watchPostEffect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   "withCtx": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDefaults": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   "withDirectives": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withMemo": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   "withModifiers": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Vue": () => (/* reexport module object */ vue__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "Vue2": () => (/* binding */ Vue2),
/* harmony export */   "isVue2": () => (/* binding */ isVue2),
/* harmony export */   "isVue3": () => (/* binding */ isVue3),
/* harmony export */   "install": () => (/* binding */ install)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm-bundler.js");


var isVue2 = false
var isVue3 = true
var Vue2 = undefined

function install() {}

function set(target, key, val) {
  if (Array.isArray(target)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  target[key] = val
  return val
}

function del(target, key) {
  if (Array.isArray(target)) {
    target.splice(key, 1)
    return
  }
  delete target[key]
}





/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdnVlbGlkYXRlX2NvcmVfZGlzdF9pbmRleF9lc21fanMtbm9kZV9tb2R1bGVzX3Z1ZWxpZGF0ZV92YWxpZGF0b3JzX2Rpc3RfLTYxMDczNy5taW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF1TDs7QUFFdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUFLO0FBQ2hCO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQVUsV0FBVyxvREFBVTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVksbUJBQW1CO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOztBQUVBO0FBQ0EsNkJBQTZCLCtDQUFLLFNBQVMsK0NBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRSxXQUFXLG1CQUFtQjtBQUM5QixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUFHO0FBQ3RCLDBCQUEwQiw2Q0FBRztBQUM3QjtBQUNBLG1CQUFtQiwrQ0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9C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O0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFOE87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDejdCcE47O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1CO0FBT2xCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pDeUI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1CO0FBT2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmVhcmJlYWNoLy4vbm9kZV9tb2R1bGVzL0B2dWVsaWRhdGUvY29yZS9kaXN0L2luZGV4LmVzbS5qcyIsIndlYnBhY2s6Ly9uZWFyYmVhY2gvLi9ub2RlX21vZHVsZXMvQHZ1ZWxpZGF0ZS92YWxpZGF0b3JzL2Rpc3QvaW5kZXguZXNtLmpzIiwid2VicGFjazovL25lYXJiZWFjaC8uL25vZGVfbW9kdWxlcy9AdnVlbGlkYXRlL2NvcmUvbm9kZV9tb2R1bGVzL3Z1ZS1kZW1pL2xpYi9pbmRleC5tanMiLCJ3ZWJwYWNrOi8vbmVhcmJlYWNoLy4vbm9kZV9tb2R1bGVzL0B2dWVsaWRhdGUvdmFsaWRhdG9ycy9ub2RlX21vZHVsZXMvdnVlLWRlbWkvbGliL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCB1bnJlZiwgcmVmLCBjb21wdXRlZCwgd2F0Y2gsIHJlYWN0aXZlLCBpc1JlZiwgbmV4dFRpY2ssIGluamVjdCwgcHJvdmlkZSwgZ2V0Q3VycmVudEluc3RhbmNlLCBpc1Z1ZTMsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCB9IGZyb20gJ3Z1ZS1kZW1pJztcblxuZnVuY3Rpb24gdW53cmFwT2JqKG9iaikge1xuICBsZXQgaWdub3JlS2V5cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgobywgaykgPT4ge1xuICAgIGlmIChpZ25vcmVLZXlzLmluY2x1ZGVzKGspKSByZXR1cm4gbztcbiAgICBvW2tdID0gdW5yZWYob2JqW2tdKTtcbiAgICByZXR1cm4gbztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSZXNwb25zZSBmb3JtIGEgcmF3IFZhbGlkYXRvciBmdW5jdGlvbi5cbiAqIFNob3VsZCByZXR1cm4gYSBCb29sZWFuIG9yIGFuIG9iamVjdCB3aXRoICRpbnZhbGlkIHByb3BlcnR5LlxuICogQHR5cGVkZWYge0Jvb2xlYW4gfCB7ICR2YWxpZDogQm9vbGVhbiB9fSBWYWxpZGF0b3JSZXNwb25zZVxuICovXG5cbi8qKlxuICogQ2FsbHMgYSB2YWxpZGF0aW9uIHJ1bGUgYnkgdW53cmFwcGluZyBpdHMgdmFsdWUgZmlyc3QgZnJvbSBhIHJlZi5cbiAqIEBwYXJhbSB7VmFsaWRhdG9yfSBydWxlXG4gKiBAcGFyYW0ge1JlZn0gdmFsdWVcbiAqIEBwYXJhbSB7VnVlSW5zdGFuY2V9IGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gc2libGluZ1N0YXRlXG4gKiBAcmV0dXJuIHtQcm9taXNlPFZhbGlkYXRvclJlc3BvbnNlPiB8IFZhbGlkYXRvclJlc3BvbnNlfVxuICovXG5cbmZ1bmN0aW9uIGNhbGxSdWxlKHJ1bGUsIHZhbHVlLCBzaWJsaW5nU3RhdGUsIGluc3RhbmNlKSB7XG4gIHJldHVybiBydWxlLmNhbGwoaW5zdGFuY2UsIHVucmVmKHZhbHVlKSwgdW5yZWYoc2libGluZ1N0YXRlKSwgaW5zdGFuY2UpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB2YWxpZGF0b3IgcmVzdWx0XG4gKiBBbGxvd3MgcGFzc2luZyBhIGJvb2xlYW4gb2YgYW4gb2JqZWN0IGxpa2UgYHsgJHZhbGlkOiBCb29sZWFuIH1gXG4gKiBAcGFyYW0ge1ZhbGlkYXRvclJlc3BvbnNlfSByZXN1bHQgLSBWYWxpZGF0b3IgcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsaWRhdG9yUmVzcG9uc2UocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQuJHZhbGlkICE9PSB1bmRlZmluZWQgPyAhcmVzdWx0LiR2YWxpZCA6ICFyZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhbiBhc3luYyB2YWxpZGF0b3IuXG4gKiBAcGFyYW0ge1ZhbGlkYXRvcn0gcnVsZVxuICogQHBhcmFtIHtSZWY8Kj59IG1vZGVsXG4gKiBAcGFyYW0ge1JlZjxCb29sZWFuPn0gJHBlbmRpbmdcbiAqIEBwYXJhbSB7UmVmPEJvb2xlYW4+fSAkZGlydHlcbiAqIEBwYXJhbSB7R2xvYmFsQ29uZmlnfSBjb25maWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLiRsYXp5XG4gKiBAcGFyYW0ge1JlZjwqPn0gJHJlc3BvbnNlXG4gKiBAcGFyYW0ge1Z1ZUluc3RhbmNlfSBpbnN0YW5jZVxuICogQHBhcmFtIHtSZWY8Kj5bXX0gd2F0Y2hUYXJnZXRzXG4gKiBAcGFyYW0ge09iamVjdH0gc2libGluZ1N0YXRlXG4gKiBAcGFyYW0ge1JlZjxCb29sZWFuPn0gJGxhc3RJbnZhbGlkU3RhdGVcbiAqIEBwYXJhbSB7UmVmPE51bWJlcj59ICRsYXN0Q29tbWl0dGVkT25cbiAqIEByZXR1cm4ge3sgJGludmFsaWQ6IFJlZjxCb29sZWFuPiwgJHVud2F0Y2g6IFdhdGNoU3RvcEhhbmRsZSB9fVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNSZXN1bHQocnVsZSwgbW9kZWwsICRwZW5kaW5nLCAkZGlydHksIF9yZWYsICRyZXNwb25zZSwgaW5zdGFuY2UpIHtcbiAgbGV0IHtcbiAgICAkbGF6eSxcbiAgICAkcmV3YXJkRWFybHlcbiAgfSA9IF9yZWY7XG4gIGxldCB3YXRjaFRhcmdldHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNyAmJiBhcmd1bWVudHNbN10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s3XSA6IFtdO1xuICBsZXQgc2libGluZ1N0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDggPyBhcmd1bWVudHNbOF0gOiB1bmRlZmluZWQ7XG4gIGxldCAkbGFzdEludmFsaWRTdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA5ID8gYXJndW1lbnRzWzldIDogdW5kZWZpbmVkO1xuICBsZXQgJGxhc3RDb21taXR0ZWRPbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxMCA/IGFyZ3VtZW50c1sxMF0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0ICRpbnZhbGlkID0gcmVmKCEhJGRpcnR5LnZhbHVlKTtcbiAgY29uc3QgJHBlbmRpbmdDb3VudGVyID0gcmVmKDApO1xuICAkcGVuZGluZy52YWx1ZSA9IGZhbHNlO1xuICBjb25zdCAkdW53YXRjaCA9IHdhdGNoKFttb2RlbCwgJGRpcnR5XS5jb25jYXQod2F0Y2hUYXJnZXRzLCAkbGFzdENvbW1pdHRlZE9uKSwgKCkgPT4ge1xuICAgIGlmICggLy8gaWYgJGxhenkgYW5kIG5vdCBkaXJ0eSwgcmV0dXJuXG4gICAgJGxhenkgJiYgISRkaXJ0eS52YWx1ZSB8fCAvLyBpZiBpbiAkcmV3YXJkRWFybHkgbW9kZSBhbmQgbm8gcHJldmlvdXMgZXJyb3JzLCBub3RoaW5nIHBlbmRpbmcsIHJldHVyblxuICAgICRyZXdhcmRFYXJseSAmJiAhJGxhc3RJbnZhbGlkU3RhdGUudmFsdWUgJiYgISRwZW5kaW5nLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJ1bGVSZXN1bHQ7IC8vIG1ha2Ugc3VyZSB3ZSBkb250IGJyZWFrIGlmIGEgdmFsaWRhdG9yIHRocm93c1xuXG4gICAgdHJ5IHtcbiAgICAgIHJ1bGVSZXN1bHQgPSBjYWxsUnVsZShydWxlLCBtb2RlbCwgc2libGluZ1N0YXRlLCBpbnN0YW5jZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBjb252ZXJ0IHRvIGEgcHJvbWlzZSwgc28gd2UgY2FuIGhhbmRsZSBpdCBhc3luY1xuICAgICAgcnVsZVJlc3VsdCA9IFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgJHBlbmRpbmdDb3VudGVyLnZhbHVlKys7XG4gICAgJHBlbmRpbmcudmFsdWUgPSAhISRwZW5kaW5nQ291bnRlci52YWx1ZTsgLy8gZW5zdXJlICRpbnZhbGlkIGlzIGZhbHNlLCB3aGlsZSB2YWxpZGF0b3IgaXMgcmVzb2x2aW5nXG5cbiAgICAkaW52YWxpZC52YWx1ZSA9IGZhbHNlO1xuICAgIFByb21pc2UucmVzb2x2ZShydWxlUmVzdWx0KS50aGVuKGRhdGEgPT4ge1xuICAgICAgJHBlbmRpbmdDb3VudGVyLnZhbHVlLS07XG4gICAgICAkcGVuZGluZy52YWx1ZSA9ICEhJHBlbmRpbmdDb3VudGVyLnZhbHVlO1xuICAgICAgJHJlc3BvbnNlLnZhbHVlID0gZGF0YTtcbiAgICAgICRpbnZhbGlkLnZhbHVlID0gbm9ybWFsaXplVmFsaWRhdG9yUmVzcG9uc2UoZGF0YSk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgJHBlbmRpbmdDb3VudGVyLnZhbHVlLS07XG4gICAgICAkcGVuZGluZy52YWx1ZSA9ICEhJHBlbmRpbmdDb3VudGVyLnZhbHVlO1xuICAgICAgJHJlc3BvbnNlLnZhbHVlID0gZXJyb3I7XG4gICAgICAkaW52YWxpZC52YWx1ZSA9IHRydWU7XG4gICAgfSk7XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgZGVlcDogdHlwZW9mIG1vZGVsID09PSAnb2JqZWN0J1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAkaW52YWxpZCxcbiAgICAkdW53YXRjaFxuICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBzeW5jIHZhbGlkYXRvclxuICogQHBhcmFtIHtWYWxpZGF0b3J9IHJ1bGVcbiAqIEBwYXJhbSB7UmVmPCo+fSBtb2RlbFxuICogQHBhcmFtIHtSZWY8Qm9vbGVhbj59ICRkaXJ0eVxuICogQHBhcmFtIHtHbG9iYWxDb25maWd9IGNvbmZpZ1xuICogQHBhcmFtIHtCb29sZWFufSBjb25maWcuJGxhenlcbiAqIEBwYXJhbSB7UmVmPCo+fSAkcmVzcG9uc2VcbiAqIEBwYXJhbSB7VnVlSW5zdGFuY2V9IGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gc2libGluZ1N0YXRlXG4gKiBAcGFyYW0ge1JlZjxCb29sZWFuPn0gJGxhc3RJbnZhbGlkU3RhdGVcbiAqIEByZXR1cm4ge3skdW53YXRjaDogKGZ1bmN0aW9uKCk6IHt9KSwgJGludmFsaWQ6IENvbXB1dGVkUmVmPGJvb2xlYW4+fX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVN5bmNSZXN1bHQocnVsZSwgbW9kZWwsICRkaXJ0eSwgX3JlZjIsICRyZXNwb25zZSwgaW5zdGFuY2UsIHNpYmxpbmdTdGF0ZSwgJGxhc3RJbnZhbGlkU3RhdGUpIHtcbiAgbGV0IHtcbiAgICAkbGF6eSxcbiAgICAkcmV3YXJkRWFybHlcbiAgfSA9IF9yZWYyO1xuXG4gIGNvbnN0ICR1bndhdGNoID0gKCkgPT4gKHt9KTtcblxuICBjb25zdCAkaW52YWxpZCA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoIC8vIHJldHVybiBlYXJseSBpZiAkbGF6eSBtb2RlIGFuZCBub3QgdG91Y2hlZFxuICAgICRsYXp5ICYmICEkZGlydHkudmFsdWUgfHwgLy8gSWYgJHJld2FyZEVhcmx5IG1vZGUgaXMgT04gYW5kIGxhc3QgaW52YWxpZCB3YXMgZmFsc2UgKG5vIGVycm9yKSwgcmV0dXJuIGl0LlxuICAgIC8vIElmIHdlIHdhbnQgdG8gaW52YWxpZGF0ZSwgd2UganVzdCBmbGlwIHRoZSBsYXN0IHN0YXRlIHRvIHRydWUsIGNhdXNpbmcgdGhlIGNvbXB1dGVkIHRvIHJ1biBhZ2FpblxuICAgICRyZXdhcmRFYXJseSAmJiAhJGxhc3RJbnZhbGlkU3RhdGUudmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxSdWxlKHJ1bGUsIG1vZGVsLCBzaWJsaW5nU3RhdGUsIGluc3RhbmNlKTtcbiAgICAgICRyZXNwb25zZS52YWx1ZSA9IHJlc3VsdDtcbiAgICAgIHJldHVyblZhbHVlID0gbm9ybWFsaXplVmFsaWRhdG9yUmVzcG9uc2UocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZXNwb25zZS52YWx1ZSA9IGVycjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgICR1bndhdGNoLFxuICAgICRpbnZhbGlkXG4gIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbGlkYXRpb24gcmVzdWx0LlxuICogRGV0ZWN0cyBhc3luYyBhbmQgc3luYyB2YWxpZGF0b3JzLlxuICogQHBhcmFtIHtOb3JtYWxpemVkVmFsaWRhdG9yfSBydWxlXG4gKiBAcGFyYW0ge1JlZjwqPn0gbW9kZWxcbiAqIEBwYXJhbSB7UmVmPGJvb2xlYW4+fSAkZGlydHlcbiAqIEBwYXJhbSB7R2xvYmFsQ29uZmlnfSBjb25maWcgLSBWdWVsaWRhdGUgY29uZmlnXG4gKiBAcGFyYW0ge1Z1ZUluc3RhbmNlfSBpbnN0YW5jZSAtIGNvbXBvbmVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvck5hbWUgLSBuYW1lIG9mIHRoZSBjdXJyZW50IHZhbGlkYXRvclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5S2V5IC0gdGhlIGN1cnJlbnQgcHJvcGVydHkgd2UgYXJlIHZhbGlkYXRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVBhdGggLSB0aGUgZGVlcCBwYXRoIHRvIHRoZSB2YWxpZGF0ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaWJsaW5nU3RhdGVcbiAqIEBwYXJhbSB7UmVmPEJvb2xlYW4+fSAkbGFzdEludmFsaWRTdGF0ZSAtIHRoZSBsYXN0IGludmFsaWQgc3RhdGVcbiAqIEBwYXJhbSB7UmVmPE51bWJlcj59ICRsYXN0Q29tbWl0dGVkT24gLSB0aGUgbGFzdCB0aW1lICRjb21taXQgd2FzIGNhbGxlZFxuICogQHJldHVybiB7eyAkcGFyYW1zOiAqLCAkbWVzc2FnZTogUmVmPFN0cmluZz4sICRwZW5kaW5nOiBSZWY8Qm9vbGVhbj4sICRpbnZhbGlkOiBSZWY8Qm9vbGVhbj4sICRyZXNwb25zZTogUmVmPCo+LCAkdW53YXRjaDogV2F0Y2hTdG9wSGFuZGxlIH19XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3JSZXN1bHQocnVsZSwgbW9kZWwsICRkaXJ0eSwgY29uZmlnLCBpbnN0YW5jZSwgdmFsaWRhdG9yTmFtZSwgcHJvcGVydHlLZXksIHByb3BlcnR5UGF0aCwgc2libGluZ1N0YXRlLCAkbGFzdEludmFsaWRTdGF0ZSwgJGxhc3RDb21taXR0ZWRPbikge1xuICBjb25zdCAkcGVuZGluZyA9IHJlZihmYWxzZSk7XG4gIGNvbnN0ICRwYXJhbXMgPSBydWxlLiRwYXJhbXMgfHwge307XG4gIGNvbnN0ICRyZXNwb25zZSA9IHJlZihudWxsKTtcbiAgbGV0ICRpbnZhbGlkO1xuICBsZXQgJHVud2F0Y2g7XG5cbiAgaWYgKHJ1bGUuJGFzeW5jKSB7XG4gICAgKHtcbiAgICAgICRpbnZhbGlkLFxuICAgICAgJHVud2F0Y2hcbiAgICB9ID0gY3JlYXRlQXN5bmNSZXN1bHQocnVsZS4kdmFsaWRhdG9yLCBtb2RlbCwgJHBlbmRpbmcsICRkaXJ0eSwgY29uZmlnLCAkcmVzcG9uc2UsIGluc3RhbmNlLCBydWxlLiR3YXRjaFRhcmdldHMsIHNpYmxpbmdTdGF0ZSwgJGxhc3RJbnZhbGlkU3RhdGUsICRsYXN0Q29tbWl0dGVkT24pKTtcbiAgfSBlbHNlIHtcbiAgICAoe1xuICAgICAgJGludmFsaWQsXG4gICAgICAkdW53YXRjaFxuICAgIH0gPSBjcmVhdGVTeW5jUmVzdWx0KHJ1bGUuJHZhbGlkYXRvciwgbW9kZWwsICRkaXJ0eSwgY29uZmlnLCAkcmVzcG9uc2UsIGluc3RhbmNlLCBzaWJsaW5nU3RhdGUsICRsYXN0SW52YWxpZFN0YXRlKSk7XG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0gcnVsZS4kbWVzc2FnZTtcbiAgY29uc3QgJG1lc3NhZ2UgPSBpc0Z1bmN0aW9uKG1lc3NhZ2UpID8gY29tcHV0ZWQoKCkgPT4gbWVzc2FnZSh1bndyYXBPYmooe1xuICAgICRwZW5kaW5nLFxuICAgICRpbnZhbGlkLFxuICAgICRwYXJhbXM6IHVud3JhcE9iaigkcGFyYW1zKSxcbiAgICAvLyAkcGFyYW1zIGNhbiBob2xkIHJlZnMsIHNvIHdlIHVud3JhcCB0aGVtIGZvciBlYXN5IGFjY2Vzc1xuICAgICRtb2RlbDogbW9kZWwsXG4gICAgJHJlc3BvbnNlLFxuICAgICR2YWxpZGF0b3I6IHZhbGlkYXRvck5hbWUsXG4gICAgJHByb3BlcnR5UGF0aDogcHJvcGVydHlQYXRoLFxuICAgICRwcm9wZXJ0eTogcHJvcGVydHlLZXlcbiAgfSkpKSA6IG1lc3NhZ2UgfHwgJyc7XG4gIHJldHVybiB7XG4gICAgJG1lc3NhZ2UsXG4gICAgJHBhcmFtcyxcbiAgICAkcGVuZGluZyxcbiAgICAkaW52YWxpZCxcbiAgICAkcmVzcG9uc2UsXG4gICAgJHVud2F0Y2hcbiAgfTtcbn1cblxuLyoqXG4gKiBTb3J0cyBhIHZhbGlkYXRpb24gZGVmaW5pdGlvbiBpbnRvIHJ1bGVzLCBjb25maWdzIGFuZCBuZXN0ZWQgdmFsaWRhdG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3J8RnVuY3Rpb24+fSB2YWxpZGF0aW9uc1Jhd1xuICogQHJldHVybiB7eyBydWxlczogT2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3I+LCBuZXN0ZWRWYWxpZGF0b3JzOiBPYmplY3QsIGNvbmZpZzogR2xvYmFsQ29uZmlnIH19XG4gKi9cblxuZnVuY3Rpb24gc29ydFZhbGlkYXRpb25zKCkge1xuICBsZXQgdmFsaWRhdGlvbnNSYXcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjb25zdCB2YWxpZGF0aW9ucyA9IHVucmVmKHZhbGlkYXRpb25zUmF3KTtcbiAgY29uc3QgdmFsaWRhdGlvbktleXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0aW9ucyk7XG4gIGNvbnN0IHJ1bGVzID0ge307XG4gIGNvbnN0IG5lc3RlZFZhbGlkYXRvcnMgPSB7fTtcbiAgY29uc3QgY29uZmlnID0ge307XG4gIHZhbGlkYXRpb25LZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCB2ID0gdmFsaWRhdGlvbnNba2V5XTtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBub3JtYWxpemVkLCB1c2UgaXRcbiAgICAgIGNhc2UgaXNGdW5jdGlvbih2LiR2YWxpZGF0b3IpOlxuICAgICAgICBydWxlc1trZXldID0gdjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBJZiBpdCBpcyBqdXN0IGEgZnVuY3Rpb24sIG5vcm1hbGl6ZSBpdCBmaXJzdFxuICAgICAgLy8gaW50byB7ICR2YWxpZGF0b3I6IDxGdW4+IH1cblxuICAgICAgY2FzZSBpc0Z1bmN0aW9uKHYpOlxuICAgICAgICBydWxlc1trZXldID0ge1xuICAgICAgICAgICR2YWxpZGF0b3I6IHZcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBDYXRjaCAkLXByZWZpeGVkIHByb3BlcnRpZXMgYXMgY29uZmlnXG5cbiAgICAgIGNhc2Uga2V5LnN0YXJ0c1dpdGgoJyQnKTpcbiAgICAgICAgY29uZmlnW2tleV0gPSB2O1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIElmIGl0IGRvZXNu4oCZdCBtYXRjaCBhbnkgb2YgdGhlIGFib3ZlLFxuICAgICAgLy8gdHJlYXQgYXMgbmVzdGVkVmFsaWRhdG9ycyBzdGF0ZSBwcm9wZXJ0eVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuZXN0ZWRWYWxpZGF0b3JzW2tleV0gPSB2O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcnVsZXMsXG4gICAgbmVzdGVkVmFsaWRhdG9ycyxcbiAgICBjb25maWdcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2VtcHR5KCkge31cblxuY29uc3QgUk9PVF9QQVRIID0gJ19fcm9vdCc7XG4vKiogQHR5cGVkZWYge2ltcG9ydCgndnVlLWRlbWknKS5Db21wb25lbnRQdWJsaWNJbnN0YW5jZX0gVnVlSW5zdGFuY2UgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ3Z1ZS1kZW1pJykuQ29tcHV0ZWRSZWZ9IENvbXB1dGVkUmVmICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCd2dWUtZGVtaScpLlVud3JhcFJlZn0gVW53cmFwUmVmICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCd2dWUtZGVtaScpLldhdGNoU3RvcEhhbmRsZX0gV2F0Y2hTdG9wSGFuZGxlICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCd2dWUtZGVtaScpLldyaXRhYmxlQ29tcHV0ZWRSZWZ9IFdyaXRhYmxlQ29tcHV0ZWRSZWYgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ3Z1ZS1kZW1pJykuVW53cmFwTmVzdGVkUmVmc30gVW53cmFwTmVzdGVkUmVmcyAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIE5vcm1hbGl6ZWRWYWxpZGF0b3JcbiAqIEBwcm9wZXJ0eSB7VmFsaWRhdG9yfSAkdmFsaWRhdG9yXG4gKiBAcHJvcGVydHkge1N0cmluZyB8IFJlZjxTdHJpbmc+IHwgZnVuY3Rpb24oKik6IHN0cmluZ30gWyRtZXNzYWdlXVxuICogQHByb3BlcnR5IHtPYmplY3QgfCBSZWY8T2JqZWN0Pn0gWyRwYXJhbXNdXG4gKiBAcHJvcGVydHkge09iamVjdCB8IFJlZjxPYmplY3Q+fSBbJGFzeW5jXVxuICogQHByb3BlcnR5IHtSZWY8Kj5bXX0gWyR3YXRjaFRhcmdldHNdXG4gKi9cblxuLyoqXG4gKiBSYXcgdmFsaWRhdG9yIGZ1bmN0aW9uLCBiZWZvcmUgYmVpbmcgbm9ybWFsaXplZFxuICogQ2FuIHJldHVybiBhIFByb21pc2Ugb3IgYSB7QHNlZSBWYWxpZGF0b3JSZXNwb25zZX1cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigqKTogKChQcm9taXNlPFZhbGlkYXRvclJlc3BvbnNlPiB8IFZhbGlkYXRvclJlc3BvbnNlKSl9IFZhbGlkYXRvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRXJyb3JPYmplY3RcbiAqIEBwcm9wZXJ0eSB7UmVmPFN0cmluZz59ICRtZXNzYWdlIC0gUmVhY3RpdmUgZXJyb3IgbWVzc2FnZVxuICogQHByb3BlcnR5IHtSZWY8T2JqZWN0Pn0gJHBhcmFtcyAtIFBhcmFtcyBwYXNzZWQgZnJvbSB3aXRoUGFyYW1zXG4gKiBAcHJvcGVydHkge1JlZjxCb29sZWFuPn0gJHBlbmRpbmcgLSBJZiB2YWxpZGF0aW9uIGlzIHBlbmRpbmdcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAkcHJvcGVydHkgLSBTdGF0ZSBrZXlcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAkcHJvcGVydHlQYXRoIC0gRG90IG5vdGF0aW9uIHBhdGggdG8gc3RhdGVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAkdmFsaWRhdG9yIC0gVmFsaWRhdG9yIG5hbWVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAkdWlkIC0gVW5pcXVlIGlkZW50aWZpZXJcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFZhbGlkYXRpb25SZXN1bHRcbiAqIEBwcm9wZXJ0eSB7UmVmPEJvb2xlYW4+fSAkcGVuZGluZ1xuICogQHByb3BlcnR5IHtSZWY8Qm9vbGVhbj59ICRkaXJ0eVxuICogQHByb3BlcnR5IHtSZWY8Qm9vbGVhbj59ICRpbnZhbGlkXG4gKiBAcHJvcGVydHkge1JlZjxCb29sZWFuPn0gJGVycm9yXG4gKiBAcHJvcGVydHkge1JlZjxTdHJpbmc+fSAkcGF0aFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gJHRvdWNoXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAkcmVzZXRcbiAqIEBwcm9wZXJ0eSB7Q29tcHV0ZWRSZWY8RXJyb3JPYmplY3RbXT59ICRlcnJvcnNcbiAqIEBwcm9wZXJ0eSB7Q29tcHV0ZWRSZWY8RXJyb3JPYmplY3RbXT59ICRzaWxlbnRFcnJvcnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259ICRjb21taXRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIG1haW4gVmFsaWRhdGlvbiBSZXN1bHRzIG9iamVjdCBmb3IgYSBzdGF0ZSB0cmVlXG4gKiBXYWxrcyB0aGUgdHJlZSdzIHRvcCBsZXZlbCBicmFuY2hlc1xuICogQHBhcmFtIHtPYmplY3Q8Tm9ybWFsaXplZFZhbGlkYXRvcj59IHJ1bGVzIC0gUnVsZXMgZm9yIHRoZSBjdXJyZW50IHN0YXRlIHRyZWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCAtIEN1cnJlbnQgc3RhdGUgdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBLZXkgZm9yIHRoZSBjdXJyZW50IHN0YXRlIHRyZWVcbiAqIEBwYXJhbSB7UmVzdWx0c1N0b3JhZ2V9IFtyZXN1bHRzQ2FjaGVdIC0gQSBjYWNoZSBtYXAgb2YgYWxsIHRoZSB2YWxpZGF0b3JzXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIC0gdGhlIGN1cnJlbnQgcHJvcGVydHkgcGF0aFxuICogQHBhcmFtIHtHbG9iYWxDb25maWd9IFtjb25maWddIC0gdGhlIGNvbmZpZyBvYmplY3RcbiAqIEBwYXJhbSB7VnVlSW5zdGFuY2V9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0NvbXB1dGVkUmVmPE9iamVjdD59IGV4dGVybmFsUmVzdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IHNpYmxpbmdTdGF0ZVxuICogQHJldHVybiB7VmFsaWRhdGlvblJlc3VsdCB8IHt9fVxuICovXG5cbmZ1bmN0aW9uIF9jYWxsKGJvZHksIHRoZW4sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgcmV0dXJuIHRoZW4gPyB0aGVuKGJvZHkoKSkgOiBib2R5KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciByZXN1bHQgPSBQcm9taXNlLnJlc29sdmUoYm9keSgpKTtcbiAgICByZXR1cm4gdGhlbiA/IHJlc3VsdC50aGVuKHRoZW4pIDogcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICB9XG59XG4vKipcbiAqIENvbGxlY3RzIHRoZSB2YWxpZGF0aW9uIHJlc3VsdHMgb2YgYWxsIG5lc3RlZCBzdGF0ZSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdDxOb3JtYWxpemVkVmFsaWRhdG9yfEZ1bmN0aW9uPn0gdmFsaWRhdGlvbnMgLSBUaGUgdmFsaWRhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG5lc3RlZFN0YXRlIC0gQ3VycmVudCBzdGF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBQYXRoIHRvIGN1cnJlbnQgcHJvcGVydHlcbiAqIEBwYXJhbSB7UmVzdWx0c1N0b3JhZ2V9IHJlc3VsdHNDYWNoZSAtIFZhbGlkYXRpb25zIGNhY2hlIG1hcFxuICogQHBhcmFtIHtHbG9iYWxDb25maWd9IGNvbmZpZyAtIFRoZSBjb25maWcgb2JqZWN0XG4gKiBAcGFyYW0ge1Z1ZUluc3RhbmNlfSBpbnN0YW5jZSAtIFRoZSBjdXJyZW50IFZ1ZSBpbnN0YW5jZVxuICogQHBhcmFtIHtDb21wdXRlZFJlZjxvYmplY3Q+fSBuZXN0ZWRFeHRlcm5hbFJlc3VsdHMgLSBUaGUgZXh0ZXJuYWwgcmVzdWx0cyBmb3IgdGhpcyBuZXN0ZWQgY29sbGVjdGlvblxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgVnVlbGlkYXRlU3RhdGU+fVxuICovXG5cblxuZnVuY3Rpb24gX2NhbGxJZ25vcmVkKGJvZHksIGRpcmVjdCkge1xuICByZXR1cm4gX2NhbGwoYm9keSwgX2VtcHR5LCBkaXJlY3QpO1xufVxuXG5mdW5jdGlvbiBfaW52b2tlKGJvZHksIHRoZW4pIHtcbiAgdmFyIHJlc3VsdCA9IGJvZHkoKTtcblxuICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG4gICAgcmV0dXJuIHJlc3VsdC50aGVuKHRoZW4pO1xuICB9XG5cbiAgcmV0dXJuIHRoZW4ocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gX2FzeW5jKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhcmdzID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYuYXBwbHkodGhpcywgYXJncykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb25SZXN1bHRzKHJ1bGVzLCBtb2RlbCwga2V5LCByZXN1bHRzQ2FjaGUsIHBhdGgsIGNvbmZpZywgaW5zdGFuY2UsIGV4dGVybmFsUmVzdWx0cywgc2libGluZ1N0YXRlKSB7XG4gIC8vIGNvbGxlY3QgdGhlIHByb3BlcnR5IGtleXNcbiAgY29uc3QgcnVsZUtleXMgPSBPYmplY3Qua2V5cyhydWxlcyk7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IHJlc3VsdHNDYWNoZS5nZXQocGF0aCwgcnVsZXMpO1xuICBjb25zdCAkZGlydHkgPSByZWYoZmFsc2UpOyAvLyBzdGF0ZSBmb3IgdGhlICRyZXdhcmRFYXJseSBvcHRpb25cblxuICAvKiogVGhlIGxhc3QgaW52YWxpZCBzdGF0ZSBvZiB0aGlzIHByb3BlcnR5ICovXG5cbiAgY29uc3QgJGxhc3RJbnZhbGlkU3RhdGUgPSByZWYoZmFsc2UpO1xuICAvKiogVGhlIGxhc3QgdGltZSAkY29tbWl0IHdhcyBjYWxsZWQuIFVzZWQgdG8gcmUtdHJpZ2dlciBhc3luYyBjYWxscyAqL1xuXG4gIGNvbnN0ICRsYXN0Q29tbWl0dGVkT24gPSByZWYoMCk7XG5cbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIC8vIGlmIHRoZSBydWxlcyBhcmUgdGhlIHNhbWUgYXMgYmVmb3JlLCB1c2UgdGhlIGNhY2hlZCByZXN1bHRzXG4gICAgaWYgKCFjYWNoZWRSZXN1bHQuJHBhcnRpYWwpIHJldHVybiBjYWNoZWRSZXN1bHQ7IC8vIHJlbW92ZSBvbGQgd2F0Y2hlcnNcblxuICAgIGNhY2hlZFJlc3VsdC4kdW53YXRjaCgpOyAvLyB1c2UgdGhlIGAkZGlydHkudmFsdWVgLCBzbyB3ZSBkb250IHNhdmUgcmVmZXJlbmNlcyBieSBhY2NpZGVudFxuXG4gICAgJGRpcnR5LnZhbHVlID0gY2FjaGVkUmVzdWx0LiRkaXJ0eS52YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAvLyByZXN0b3JlICRkaXJ0eSBmcm9tIGNhY2hlXG4gICAgJGRpcnR5LFxuICAgICRwYXRoOiBwYXRoLFxuICAgICR0b3VjaDogKCkgPT4ge1xuICAgICAgaWYgKCEkZGlydHkudmFsdWUpICRkaXJ0eS52YWx1ZSA9IHRydWU7XG4gICAgfSxcbiAgICAkcmVzZXQ6ICgpID0+IHtcbiAgICAgIGlmICgkZGlydHkudmFsdWUpICRkaXJ0eS52YWx1ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgJGNvbW1pdDogKCkgPT4ge31cbiAgfTtcbiAgLyoqXG4gICAqIElmIHRoZXJlIGFyZSBubyB2YWxpZGF0aW9uIHJ1bGVzLCBpdCBpcyBtb3N0IGxpa2VseVxuICAgKiBhIHRvcCBsZXZlbCBzdGF0ZSwgYWthIHJvb3RcbiAgICovXG5cbiAgaWYgKCFydWxlS2V5cy5sZW5ndGgpIHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgY2FjaGVkIHJlc3VsdHMsIHdlIHNob3VsZCBvdmVyd3JpdGUgdGhlbSB3aXRoIHRoZSBuZXcgb25lc1xuICAgIGNhY2hlZFJlc3VsdCAmJiByZXN1bHRzQ2FjaGUuc2V0KHBhdGgsIHJ1bGVzLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBydWxlS2V5cy5mb3JFYWNoKHJ1bGVLZXkgPT4ge1xuICAgIHJlc3VsdFtydWxlS2V5XSA9IGNyZWF0ZVZhbGlkYXRvclJlc3VsdChydWxlc1tydWxlS2V5XSwgbW9kZWwsIHJlc3VsdC4kZGlydHksIGNvbmZpZywgaW5zdGFuY2UsIHJ1bGVLZXksIGtleSwgcGF0aCwgc2libGluZ1N0YXRlLCAkbGFzdEludmFsaWRTdGF0ZSwgJGxhc3RDb21taXR0ZWRPbik7XG4gIH0pO1xuICByZXN1bHQuJGV4dGVybmFsUmVzdWx0cyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICBpZiAoIWV4dGVybmFsUmVzdWx0cy52YWx1ZSkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBbXS5jb25jYXQoZXh0ZXJuYWxSZXN1bHRzLnZhbHVlKS5tYXAoKHN0cmluZ0Vycm9yLCBpbmRleCkgPT4gKHtcbiAgICAgICRwcm9wZXJ0eVBhdGg6IHBhdGgsXG4gICAgICAkcHJvcGVydHk6IGtleSxcbiAgICAgICR2YWxpZGF0b3I6ICckZXh0ZXJuYWxSZXN1bHRzJyxcbiAgICAgICR1aWQ6IGAke3BhdGh9LWV4dGVybmFsUmVzdWx0LSR7aW5kZXh9YCxcbiAgICAgICRtZXNzYWdlOiBzdHJpbmdFcnJvcixcbiAgICAgICRwYXJhbXM6IHt9LFxuICAgICAgJHJlc3BvbnNlOiBudWxsLFxuICAgICAgJHBlbmRpbmc6IGZhbHNlXG4gICAgfSkpO1xuICB9KTtcbiAgcmVzdWx0LiRpbnZhbGlkID0gY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IHIgPSBydWxlS2V5cy5zb21lKHJ1bGVLZXkgPT4gdW5yZWYocmVzdWx0W3J1bGVLZXldLiRpbnZhbGlkKSk7IC8vIGNhY2hlIHRoZSBsYXN0IGludmFsaWQgc3RhdGVcblxuICAgICRsYXN0SW52YWxpZFN0YXRlLnZhbHVlID0gcjtcbiAgICByZXR1cm4gISFyZXN1bHQuJGV4dGVybmFsUmVzdWx0cy52YWx1ZS5sZW5ndGggfHwgcjtcbiAgfSk7XG4gIHJlc3VsdC4kcGVuZGluZyA9IGNvbXB1dGVkKCgpID0+IHJ1bGVLZXlzLnNvbWUocnVsZUtleSA9PiB1bnJlZihyZXN1bHRbcnVsZUtleV0uJHBlbmRpbmcpKSk7XG4gIHJlc3VsdC4kZXJyb3IgPSBjb21wdXRlZCgoKSA9PiByZXN1bHQuJGRpcnR5LnZhbHVlID8gcmVzdWx0LiRwZW5kaW5nLnZhbHVlIHx8IHJlc3VsdC4kaW52YWxpZC52YWx1ZSA6IGZhbHNlKTtcbiAgcmVzdWx0LiRzaWxlbnRFcnJvcnMgPSBjb21wdXRlZCgoKSA9PiBydWxlS2V5cy5maWx0ZXIocnVsZUtleSA9PiB1bnJlZihyZXN1bHRbcnVsZUtleV0uJGludmFsaWQpKS5tYXAocnVsZUtleSA9PiB7XG4gICAgY29uc3QgcmVzID0gcmVzdWx0W3J1bGVLZXldO1xuICAgIHJldHVybiByZWFjdGl2ZSh7XG4gICAgICAkcHJvcGVydHlQYXRoOiBwYXRoLFxuICAgICAgJHByb3BlcnR5OiBrZXksXG4gICAgICAkdmFsaWRhdG9yOiBydWxlS2V5LFxuICAgICAgJHVpZDogYCR7cGF0aH0tJHtydWxlS2V5fWAsXG4gICAgICAkbWVzc2FnZTogcmVzLiRtZXNzYWdlLFxuICAgICAgJHBhcmFtczogcmVzLiRwYXJhbXMsXG4gICAgICAkcmVzcG9uc2U6IHJlcy4kcmVzcG9uc2UsXG4gICAgICAkcGVuZGluZzogcmVzLiRwZW5kaW5nXG4gICAgfSk7XG4gIH0pLmNvbmNhdChyZXN1bHQuJGV4dGVybmFsUmVzdWx0cy52YWx1ZSkpO1xuICByZXN1bHQuJGVycm9ycyA9IGNvbXB1dGVkKCgpID0+IHJlc3VsdC4kZGlydHkudmFsdWUgPyByZXN1bHQuJHNpbGVudEVycm9ycy52YWx1ZSA6IFtdKTtcblxuICByZXN1bHQuJHVud2F0Y2ggPSAoKSA9PiBydWxlS2V5cy5mb3JFYWNoKHJ1bGVLZXkgPT4ge1xuICAgIHJlc3VsdFtydWxlS2V5XS4kdW53YXRjaCgpO1xuICB9KTtcblxuICByZXN1bHQuJGNvbW1pdCA9ICgpID0+IHtcbiAgICAkbGFzdEludmFsaWRTdGF0ZS52YWx1ZSA9IHRydWU7XG4gICAgJGxhc3RDb21taXR0ZWRPbi52YWx1ZSA9IERhdGUubm93KCk7XG4gIH07XG5cbiAgcmVzdWx0c0NhY2hlLnNldChwYXRoLCBydWxlcywgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29sbGVjdE5lc3RlZFZhbGlkYXRpb25SZXN1bHRzKHZhbGlkYXRpb25zLCBuZXN0ZWRTdGF0ZSwgcGF0aCwgcmVzdWx0c0NhY2hlLCBjb25maWcsIGluc3RhbmNlLCBuZXN0ZWRFeHRlcm5hbFJlc3VsdHMpIHtcbiAgY29uc3QgbmVzdGVkVmFsaWRhdGlvbktleXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0aW9ucyk7IC8vIGlmIHdlIGhhdmUgbm8gc3RhdGUsIHJldHVybiBlbXB0eSBvYmplY3RcblxuICBpZiAoIW5lc3RlZFZhbGlkYXRpb25LZXlzLmxlbmd0aCkgcmV0dXJuIHt9O1xuICByZXR1cm4gbmVzdGVkVmFsaWRhdGlvbktleXMucmVkdWNlKChyZXN1bHRzLCBuZXN0ZWRLZXkpID0+IHtcbiAgICAvLyBidWlsZCB2YWxpZGF0aW9uIHJlc3VsdHMgZm9yIG5lc3RlZCBzdGF0ZVxuICAgIHJlc3VsdHNbbmVzdGVkS2V5XSA9IHNldFZhbGlkYXRpb25zKHtcbiAgICAgIHZhbGlkYXRpb25zOiB2YWxpZGF0aW9uc1tuZXN0ZWRLZXldLFxuICAgICAgc3RhdGU6IG5lc3RlZFN0YXRlLFxuICAgICAga2V5OiBuZXN0ZWRLZXksXG4gICAgICBwYXJlbnRLZXk6IHBhdGgsXG4gICAgICByZXN1bHRzQ2FjaGUsXG4gICAgICBnbG9iYWxDb25maWc6IGNvbmZpZyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgZXh0ZXJuYWxSZXN1bHRzOiBuZXN0ZWRFeHRlcm5hbFJlc3VsdHNcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSwge30pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIE1ldGEgZmllbGRzIGZyb20gdGhlIHJlc3VsdHNcbiAqIEBwYXJhbSB7VmFsaWRhdGlvblJlc3VsdHx7fX0gcmVzdWx0c1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgVnVlbGlkYXRlU3RhdGU+fSBuZXN0ZWRSZXN1bHRzXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBWYWxpZGF0aW9uUmVzdWx0Pn0gY2hpbGRSZXN1bHRzXG4gKiBAcmV0dXJuIHt7JGFueURpcnR5OiBSZWY8Qm9vbGVhbj4sICRlcnJvcjogUmVmPEJvb2xlYW4+LCAkaW52YWxpZDogUmVmPEJvb2xlYW4+LCAkZXJyb3JzOiBSZWY8RXJyb3JPYmplY3RbXT4sICRkaXJ0eTogUmVmPEJvb2xlYW4+LCAkdG91Y2g6IEZ1bmN0aW9uLCAkcmVzZXQ6IEZ1bmN0aW9uIH19XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVNZXRhRmllbGRzKHJlc3VsdHMsIG5lc3RlZFJlc3VsdHMsIGNoaWxkUmVzdWx0cykge1xuICBjb25zdCBhbGxSZXN1bHRzID0gY29tcHV0ZWQoKCkgPT4gW25lc3RlZFJlc3VsdHMsIGNoaWxkUmVzdWx0c10uZmlsdGVyKHJlcyA9PiByZXMpLnJlZHVjZSgoYWxsUmVzLCByZXMpID0+IHtcbiAgICByZXR1cm4gYWxsUmVzLmNvbmNhdChPYmplY3QudmFsdWVzKHVucmVmKHJlcykpKTtcbiAgfSwgW10pKTsgLy8gcmV0dXJucyBgJGRpcnR5YCBhcyB0cnVlLCBpZiBhbGwgY2hpbGRyZW4gYXJlIGRpcnR5XG5cbiAgY29uc3QgJGRpcnR5ID0gY29tcHV0ZWQoe1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiByZXN1bHRzLiRkaXJ0eS52YWx1ZSB8fCAoYWxsUmVzdWx0cy52YWx1ZS5sZW5ndGggPyBhbGxSZXN1bHRzLnZhbHVlLmV2ZXJ5KHIgPT4gci4kZGlydHkpIDogZmFsc2UpO1xuICAgIH0sXG5cbiAgICBzZXQodikge1xuICAgICAgcmVzdWx0cy4kZGlydHkudmFsdWUgPSB2O1xuICAgIH1cblxuICB9KTtcbiAgY29uc3QgJHNpbGVudEVycm9ycyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAvLyBjdXJyZW50IHN0YXRlIGxldmVsIGVycm9ycywgZmFsbGJhY2sgdG8gZW1wdHkgYXJyYXkgaWYgcm9vdFxuICAgIGNvbnN0IG1vZGVsRXJyb3JzID0gdW5yZWYocmVzdWx0cy4kc2lsZW50RXJyb3JzKSB8fCBbXTsgLy8gY29sbGVjdCBhbGwgbmVzdGVkIGFuZCBjaGlsZCAkc2lsZW50RXJyb3JzXG5cbiAgICBjb25zdCBuZXN0ZWRFcnJvcnMgPSBhbGxSZXN1bHRzLnZhbHVlLmZpbHRlcihyZXN1bHQgPT4gKHVucmVmKHJlc3VsdCkuJHNpbGVudEVycm9ycyB8fCBbXSkubGVuZ3RoKS5yZWR1Y2UoKGVycm9ycywgcmVzdWx0KSA9PiB7XG4gICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCguLi5yZXN1bHQuJHNpbGVudEVycm9ycyk7XG4gICAgfSwgW10pOyAvLyBtZXJnZSB0aGUgJHNpbGVudEVycm9yc1xuXG4gICAgcmV0dXJuIG1vZGVsRXJyb3JzLmNvbmNhdChuZXN0ZWRFcnJvcnMpO1xuICB9KTtcbiAgY29uc3QgJGVycm9ycyA9IGNvbXB1dGVkKCgpID0+IHtcbiAgICAvLyBjdXJyZW50IHN0YXRlIGxldmVsIGVycm9ycywgZmFsbGJhY2sgdG8gZW1wdHkgYXJyYXkgaWYgcm9vdFxuICAgIGNvbnN0IG1vZGVsRXJyb3JzID0gdW5yZWYocmVzdWx0cy4kZXJyb3JzKSB8fCBbXTsgLy8gY29sbGVjdCBhbGwgbmVzdGVkIGFuZCBjaGlsZCAkZXJyb3JzXG5cbiAgICBjb25zdCBuZXN0ZWRFcnJvcnMgPSBhbGxSZXN1bHRzLnZhbHVlLmZpbHRlcihyZXN1bHQgPT4gKHVucmVmKHJlc3VsdCkuJGVycm9ycyB8fCBbXSkubGVuZ3RoKS5yZWR1Y2UoKGVycm9ycywgcmVzdWx0KSA9PiB7XG4gICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCguLi5yZXN1bHQuJGVycm9ycyk7XG4gICAgfSwgW10pOyAvLyBtZXJnZSB0aGUgJGVycm9yc1xuXG4gICAgcmV0dXJuIG1vZGVsRXJyb3JzLmNvbmNhdChuZXN0ZWRFcnJvcnMpO1xuICB9KTtcbiAgY29uc3QgJGludmFsaWQgPSBjb21wdXRlZCgoKSA9PiAvLyBpZiBhbnkgb2YgdGhlIG5lc3RlZCB2YWx1ZXMgaXMgaW52YWxpZFxuICBhbGxSZXN1bHRzLnZhbHVlLnNvbWUociA9PiByLiRpbnZhbGlkKSB8fCAvLyBvciBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyBpbnZhbGlkXG4gIHVucmVmKHJlc3VsdHMuJGludmFsaWQpIHx8IC8vIGZhbGxiYWNrIHRvIGZhbHNlIGlmIGlzIHJvb3RcbiAgZmFsc2UpO1xuICBjb25zdCAkcGVuZGluZyA9IGNvbXB1dGVkKCgpID0+IC8vIGlmIGFueSBvZiB0aGUgbmVzdGVkIHZhbHVlcyBpcyBwZW5kaW5nXG4gIGFsbFJlc3VsdHMudmFsdWUuc29tZShyID0+IHVucmVmKHIuJHBlbmRpbmcpKSB8fCAvLyBpZiBhbnkgb2YgdGhlIGN1cnJlbnQgc3RhdGUgdmFsaWRhdG9ycyBpcyBwZW5kaW5nXG4gIHVucmVmKHJlc3VsdHMuJHBlbmRpbmcpIHx8IC8vIGZhbGxiYWNrIHRvIGZhbHNlIGlmIGlzIHJvb3RcbiAgZmFsc2UpO1xuICBjb25zdCAkYW55RGlydHkgPSBjb21wdXRlZCgoKSA9PiBhbGxSZXN1bHRzLnZhbHVlLnNvbWUociA9PiByLiRkaXJ0eSkgfHwgYWxsUmVzdWx0cy52YWx1ZS5zb21lKHIgPT4gci4kYW55RGlydHkpIHx8ICRkaXJ0eS52YWx1ZSk7XG4gIGNvbnN0ICRlcnJvciA9IGNvbXB1dGVkKCgpID0+ICRkaXJ0eS52YWx1ZSA/ICRwZW5kaW5nLnZhbHVlIHx8ICRpbnZhbGlkLnZhbHVlIDogZmFsc2UpO1xuXG4gIGNvbnN0ICR0b3VjaCA9ICgpID0+IHtcbiAgICAvLyBjYWxsIHRoZSByb290ICR0b3VjaFxuICAgIHJlc3VsdHMuJHRvdWNoKCk7IC8vIGNhbGwgYWxsIG5lc3RlZCBsZXZlbCAkdG91Y2hcblxuICAgIGFsbFJlc3VsdHMudmFsdWUuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgcmVzdWx0LiR0b3VjaCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0ICRjb21taXQgPSAoKSA9PiB7XG4gICAgLy8gY2FsbCB0aGUgcm9vdCAkdG91Y2hcbiAgICByZXN1bHRzLiRjb21taXQoKTsgLy8gY2FsbCBhbGwgbmVzdGVkIGxldmVsICR0b3VjaFxuXG4gICAgYWxsUmVzdWx0cy52YWx1ZS5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICByZXN1bHQuJGNvbW1pdCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0ICRyZXNldCA9ICgpID0+IHtcbiAgICAvLyByZXNldCB0aGUgcm9vdCAkZGlydHkgc3RhdGVcbiAgICByZXN1bHRzLiRyZXNldCgpOyAvLyByZXNldCBhbGwgdGhlIGNoaWxkcmVuICRkaXJ0eSBzdGF0ZXNcblxuICAgIGFsbFJlc3VsdHMudmFsdWUuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgcmVzdWx0LiRyZXNldCgpO1xuICAgIH0pO1xuICB9OyAvLyBFbnN1cmUgdGhhdCBpZiBhbGwgY2hpbGQgYW5kIG5lc3RlZCByZXN1bHRzIGFyZSAkZGlydHksIHRoaXMgYWxzbyBiZWNvbWVzICRkaXJ0eVxuXG5cbiAgaWYgKGFsbFJlc3VsdHMudmFsdWUubGVuZ3RoICYmIGFsbFJlc3VsdHMudmFsdWUuZXZlcnkobnIgPT4gbnIuJGRpcnR5KSkgJHRvdWNoKCk7XG4gIHJldHVybiB7XG4gICAgJGRpcnR5LFxuICAgICRlcnJvcnMsXG4gICAgJGludmFsaWQsXG4gICAgJGFueURpcnR5LFxuICAgICRlcnJvcixcbiAgICAkcGVuZGluZyxcbiAgICAkdG91Y2gsXG4gICAgJHJlc2V0LFxuICAgICRzaWxlbnRFcnJvcnMsXG4gICAgJGNvbW1pdFxuICB9O1xufVxuLyoqXG4gKiBAdHlwZWRlZiBWdWVsaWRhdGVTdGF0ZVxuICogQHByb3BlcnR5IHtXcml0YWJsZUNvbXB1dGVkUmVmPGFueT59ICRtb2RlbFxuICogQHByb3BlcnR5IHtDb21wdXRlZFJlZjxCb29sZWFuPn0gJGRpcnR5XG4gKiBAcHJvcGVydHkge0NvbXB1dGVkUmVmPEJvb2xlYW4+fSAkZXJyb3JcbiAqIEBwcm9wZXJ0eSB7Q29tcHV0ZWRSZWY8RXJyb3JPYmplY3RbXT59ICRlcnJvcnNcbiAqIEBwcm9wZXJ0eSB7Q29tcHV0ZWRSZWY8Qm9vbGVhbj59ICRpbnZhbGlkXG4gKiBAcHJvcGVydHkge0NvbXB1dGVkUmVmPEJvb2xlYW4+fSAkYW55RGlydHlcbiAqIEBwcm9wZXJ0eSB7Q29tcHV0ZWRSZWY8Qm9vbGVhbj59ICRwZW5kaW5nXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAkdG91Y2hcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259ICRyZXNldFxuICogQHByb3BlcnR5IHtTdHJpbmd9ICRwYXRoXG4gKiBAcHJvcGVydHkge0NvbXB1dGVkUmVmPEVycm9yT2JqZWN0W10+fSAkc2lsZW50RXJyb3JzXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbJHZhbGlkYXRlXVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gWyRnZXRSZXN1bHRzRm9yQ2hpbGRdXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBWdWVsaWRhdGVTdGF0ZT59XG4gKi9cblxuLyoqXG4gKiBNYWluIFZ1ZWxpZGF0ZSBib290c3RyYXAgZnVuY3Rpb24uXG4gKiBVc2VkIGJvdGggZm9yIENvbXBvc2l0aW9uIEFQSSBpbiBgc2V0dXBgIGFuZCBmb3IgR2xvYmFsIEFwcCB1c2FnZS5cbiAqIFVzZWQgdG8gY29sbGVjdCB2YWxpZGF0aW9uIHN0YXRlLCB3aGVuIHdhbGtpbmcgcmVjdXJzaXZlbHkgZG93biB0aGUgc3RhdGUgdHJlZVxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtPYmplY3Q8Tm9ybWFsaXplZFZhbGlkYXRvcnxGdW5jdGlvbj59IHBhcmFtcy52YWxpZGF0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy5zdGF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMua2V5XSAtIEN1cnJlbnQgc3RhdGUgcHJvcGVydHkga2V5LiBVc2VkIHdoZW4gYmVpbmcgY2FsbGVkIG9uIG5lc3RlZCBpdGVtc1xuICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbXMucGFyZW50S2V5XSAtIFBhcmVudCBzdGF0ZSBwcm9wZXJ0eSBrZXkuIFVzZWQgd2hlbiBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHlcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgVmFsaWRhdGlvblJlc3VsdD59IFtwYXJhbXMuY2hpbGRSZXN1bHRzXSAtIFVzZWQgdG8gY29sbGVjdCBjaGlsZCByZXN1bHRzLlxuICogQHBhcmFtIHtSZXN1bHRzU3RvcmFnZX0gcGFyYW1zLnJlc3VsdHNDYWNoZSAtIFRoZSBjYWNoZWQgdmFsaWRhdGlvbiByZXN1bHRzXG4gKiBAcGFyYW0ge1Z1ZUluc3RhbmNlfSBwYXJhbXMuaW5zdGFuY2UgLSBUaGUgY3VycmVudCBWdWUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7R2xvYmFsQ29uZmlnfSBwYXJhbXMuZ2xvYmFsQ29uZmlnIC0gVGhlIHZhbGlkYXRpb24gY29uZmlnLCBwYXNzZWQgdG8gdGhpcyBzZXRWYWxpZGF0aW9ucyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VW53cmFwTmVzdGVkUmVmczxvYmplY3Q+IHwgUmVmPE9iamVjdD59IHBhcmFtcy5leHRlcm5hbFJlc3VsdHMgLSBFeHRlcm5hbCB2YWxpZGF0aW9uIHJlc3VsdHNcbiAqIEByZXR1cm4ge1Vud3JhcE5lc3RlZFJlZnM8VnVlbGlkYXRlU3RhdGU+fVxuICovXG5cblxuZnVuY3Rpb24gc2V0VmFsaWRhdGlvbnMoX3JlZikge1xuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIHZhbGlkYXRvcnMgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGNvbnN0ICR2YWxpZGF0ZSA9IF9hc3luYyhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCEkZGlydHkudmFsdWUpICR0b3VjaCgpO1xuICAgIHJldHVybiBfaW52b2tlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtZXJnZWRDb25maWcuJHJld2FyZEVhcmx5KSB7XG4gICAgICAgICRjb21taXQoKTsgLy8gYXdhaXQgdGhlIHdhdGNoZXJzXG5cbiAgICAgICAgcmV0dXJuIF9jYWxsSWdub3JlZChuZXh0VGljayk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gYXdhaXQgdGhlIHdhdGNoZXJzXG4gICAgICByZXR1cm4gX2NhbGwobmV4dFRpY2ssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGl0IGlzIHZhbGlkIG9yIG5vdFxuICAgICAgICAgIGlmICghJHBlbmRpbmcudmFsdWUpIHJldHVybiByZXNvbHZlKCEkaW52YWxpZC52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgdW53YXRjaCA9IHdhdGNoKCRwZW5kaW5nLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCEkaW52YWxpZC52YWx1ZSk7XG4gICAgICAgICAgICB1bndhdGNoKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICAvKipcbiAgICogUmV0dXJucyBhIGNoaWxkIGNvbXBvbmVudCdzIHJlc3VsdHMsIGJhc2VkIG9uIHJlZ2lzdHJhdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7VnVlbGlkYXRlU3RhdGV9XG4gICAqL1xuXG5cbiAgbGV0IHtcbiAgICB2YWxpZGF0aW9ucyxcbiAgICBzdGF0ZSxcbiAgICBrZXksXG4gICAgcGFyZW50S2V5LFxuICAgIGNoaWxkUmVzdWx0cyxcbiAgICByZXN1bHRzQ2FjaGUsXG4gICAgZ2xvYmFsQ29uZmlnID0ge30sXG4gICAgaW5zdGFuY2UsXG4gICAgZXh0ZXJuYWxSZXN1bHRzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwYXRoID0gcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fS4ke2tleX1gIDoga2V5OyAvLyBTb3J0IG91dCB0aGUgdmFsaWRhdGlvbiBvYmplY3QgaW50bzpcbiAgLy8g4oCTIHJ1bGVzID0gdmFsaWRhdG9ycyBmb3IgY3VycmVudCBzdGF0ZSB0cmVlIGZyYWdtZW50XG4gIC8vIOKAlCBuZXN0ZWRWYWxpZGF0b3JzID0gbmVzdGVkIHN0YXRlIGZyYWdtZW50cyBrZXlzIHRoYXQgbWlnaHQgY29udGFpbiBtb3JlIHZhbGlkYXRvcnNcbiAgLy8g4oCTIGNvbmZpZyA9IGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGlzIHN0YXRlIGZyYWdtZW50XG5cbiAgY29uc3Qge1xuICAgIHJ1bGVzLFxuICAgIG5lc3RlZFZhbGlkYXRvcnMsXG4gICAgY29uZmlnXG4gIH0gPSBzb3J0VmFsaWRhdGlvbnModmFsaWRhdGlvbnMpO1xuICBjb25zdCBtZXJnZWRDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBnbG9iYWxDb25maWcsIGNvbmZpZyk7IC8vIGNyZWF0ZSBwcm90ZWN0ZWQgc3RhdGUgZm9yIGNhc2VzIHdoZW4gdGhlIHN0YXRlIGJyYW5jaCBkb2VzIG5vdCBleGlzdCB5ZXQuXG4gIC8vIFRoaXMgcHJvdGVjdHMgd2hlbiB1c2luZyB0aGUgT3B0aW9uc0FQSSBhcyB0aGUgZGF0YSBpcyBib3VuZCBhZnRlciB0aGUgc2V0dXAgbWV0aG9kXG5cbiAgY29uc3QgbmVzdGVkU3RhdGUgPSBrZXkgPyBjb21wdXRlZCgoKSA9PiB7XG4gICAgY29uc3QgcyA9IHVucmVmKHN0YXRlKTtcbiAgICByZXR1cm4gcyA/IHVucmVmKHNba2V5XSkgOiB1bmRlZmluZWQ7XG4gIH0pIDogc3RhdGU7IC8vIGNhY2hlIHRoZSBleHRlcm5hbCByZXN1bHRzLCBzbyB3ZSBjYW4gcmV2ZXJ0IGJhY2sgdG8gdGhlbVxuXG4gIGNvbnN0IGNhY2hlZEV4dGVybmFsUmVzdWx0cyA9IE9iamVjdC5hc3NpZ24oe30sIHVucmVmKGV4dGVybmFsUmVzdWx0cykgfHwge30pO1xuICBjb25zdCBuZXN0ZWRFeHRlcm5hbFJlc3VsdHMgPSBjb21wdXRlZCgoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHVucmVmKGV4dGVybmFsUmVzdWx0cyk7XG4gICAgaWYgKCFrZXkpIHJldHVybiByZXN1bHRzO1xuICAgIHJldHVybiByZXN1bHRzID8gdW5yZWYocmVzdWx0c1trZXldKSA6IHVuZGVmaW5lZDtcbiAgfSk7IC8vIFVzZSBydWxlcyBmb3IgdGhlIGN1cnJlbnQgc3RhdGUgZnJhZ21lbnQgYW5kIHZhbGlkYXRlIGl0XG5cbiAgY29uc3QgcmVzdWx0cyA9IGNyZWF0ZVZhbGlkYXRpb25SZXN1bHRzKHJ1bGVzLCBuZXN0ZWRTdGF0ZSwga2V5LCByZXN1bHRzQ2FjaGUsIHBhdGgsIG1lcmdlZENvbmZpZywgaW5zdGFuY2UsIG5lc3RlZEV4dGVybmFsUmVzdWx0cywgc3RhdGUpOyAvLyBVc2UgbmVzdGVkIGtleXMgdG8gcmVwZWF0IHRoZSBwcm9jZXNzXG4gIC8vICpXQVJOKjogVGhpcyBpcyByZWN1cnNpdmVcblxuICBjb25zdCBuZXN0ZWRSZXN1bHRzID0gY29sbGVjdE5lc3RlZFZhbGlkYXRpb25SZXN1bHRzKG5lc3RlZFZhbGlkYXRvcnMsIG5lc3RlZFN0YXRlLCBwYXRoLCByZXN1bHRzQ2FjaGUsIG1lcmdlZENvbmZpZywgaW5zdGFuY2UsIG5lc3RlZEV4dGVybmFsUmVzdWx0cyk7IC8vIENvbGxlY3QgYW5kIG1lcmdlIHRoaXMgbGV2ZWwgdmFsaWRhdGlvbiByZXN1bHRzXG4gIC8vIHdpdGggYWxsIG5lc3RlZCB2YWxpZGF0aW9uIHJlc3VsdHNcblxuICBjb25zdCB7XG4gICAgJGRpcnR5LFxuICAgICRlcnJvcnMsXG4gICAgJGludmFsaWQsXG4gICAgJGFueURpcnR5LFxuICAgICRlcnJvcixcbiAgICAkcGVuZGluZyxcbiAgICAkdG91Y2gsXG4gICAgJHJlc2V0LFxuICAgICRzaWxlbnRFcnJvcnMsXG4gICAgJGNvbW1pdFxuICB9ID0gY3JlYXRlTWV0YUZpZWxkcyhyZXN1bHRzLCBuZXN0ZWRSZXN1bHRzLCBjaGlsZFJlc3VsdHMpO1xuICAvKipcbiAgICogSWYgd2UgaGF2ZSBubyBga2V5YCwgdGhpcyBpcyB0aGUgdG9wIGxldmVsIHN0YXRlXG4gICAqIFdlIGRvbnQgbmVlZCBgJG1vZGVsYCB0aGVyZS5cbiAgICovXG5cbiAgY29uc3QgJG1vZGVsID0ga2V5ID8gY29tcHV0ZWQoe1xuICAgIGdldDogKCkgPT4gdW5yZWYobmVzdGVkU3RhdGUpLFxuICAgIHNldDogdmFsID0+IHtcbiAgICAgICRkaXJ0eS52YWx1ZSA9IHRydWU7XG4gICAgICBjb25zdCBzID0gdW5yZWYoc3RhdGUpO1xuICAgICAgY29uc3QgZXh0ZXJuYWwgPSB1bnJlZihleHRlcm5hbFJlc3VsdHMpO1xuXG4gICAgICBpZiAoZXh0ZXJuYWwpIHtcbiAgICAgICAgZXh0ZXJuYWxba2V5XSA9IGNhY2hlZEV4dGVybmFsUmVzdWx0c1trZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNSZWYoc1trZXldKSkge1xuICAgICAgICBzW2tleV0udmFsdWUgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KSA6IG51bGw7XG5cbiAgaWYgKGtleSAmJiBtZXJnZWRDb25maWcuJGF1dG9EaXJ0eSkge1xuICAgIHdhdGNoKG5lc3RlZFN0YXRlLCAoKSA9PiB7XG4gICAgICBpZiAoISRkaXJ0eS52YWx1ZSkgJHRvdWNoKCk7XG4gICAgICBjb25zdCBleHRlcm5hbCA9IHVucmVmKGV4dGVybmFsUmVzdWx0cyk7XG5cbiAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICBleHRlcm5hbFtrZXldID0gY2FjaGVkRXh0ZXJuYWxSZXN1bHRzW2tleV07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZmx1c2g6ICdzeW5jJ1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gJGdldFJlc3VsdHNGb3JDaGlsZChrZXkpIHtcbiAgICByZXR1cm4gKGNoaWxkUmVzdWx0cy52YWx1ZSB8fCB7fSlba2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRjbGVhckV4dGVybmFsUmVzdWx0cygpIHtcbiAgICBpZiAoaXNSZWYoZXh0ZXJuYWxSZXN1bHRzKSkge1xuICAgICAgZXh0ZXJuYWxSZXN1bHRzLnZhbHVlID0gY2FjaGVkRXh0ZXJuYWxSZXN1bHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB0aGUgZXh0ZXJuYWwgcmVzdWx0cyBzdGF0ZSB3YXMgZW1wdHksIHdlIG5lZWQgdG8gZGVsZXRlIGV2ZXJ5IHByb3BlcnR5LCBvbmUgYnkgb25lXG4gICAgICBpZiAoT2JqZWN0LmtleXMoY2FjaGVkRXh0ZXJuYWxSZXN1bHRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZXh0ZXJuYWxSZXN1bHRzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBleHRlcm5hbFJlc3VsdHNba107XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RhdGUgd2FzIG5vdCBlbXB0eSwgc28gd2UganVzdCBhc3NpZ24gaXQgYmFjayBpbnRvIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXh0ZXJuYWxSZXN1bHRzLCBjYWNoZWRFeHRlcm5hbFJlc3VsdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFjdGl2ZShPYmplY3QuYXNzaWduKHt9LCByZXN1bHRzLCB7XG4gICAgLy8gTk9URTogVGhlIG9yZGVyIGhlcmUgaXMgdmVyeSBpbXBvcnRhbnQsIHNpbmNlIHdlIHdhbnQgdG8gb3ZlcnJpZGVcbiAgICAvLyBzb21lIG9mIHRoZSAqcmVzdWx0cyogbWV0YSBmaWVsZHMgd2l0aCB0aGUgY29sbGVjdGl2ZSB2ZXJzaW9uIG9mIGl0XG4gICAgLy8gdGhhdCBpbmNsdWRlcyB0aGUgcmVzdWx0cyBvZiBuZXN0ZWQgc3RhdGUgdmFsaWRhdGlvbiByZXN1bHRzXG4gICAgJG1vZGVsLFxuICAgICRkaXJ0eSxcbiAgICAkZXJyb3IsXG4gICAgJGVycm9ycyxcbiAgICAkaW52YWxpZCxcbiAgICAkYW55RGlydHksXG4gICAgJHBlbmRpbmcsXG4gICAgJHRvdWNoLFxuICAgICRyZXNldCxcbiAgICAkcGF0aDogcGF0aCB8fCBST09UX1BBVEgsXG4gICAgJHNpbGVudEVycm9ycyxcbiAgICAkdmFsaWRhdGUsXG4gICAgJGNvbW1pdFxuICB9LCBjaGlsZFJlc3VsdHMgJiYge1xuICAgICRnZXRSZXN1bHRzRm9yQ2hpbGQsXG4gICAgJGNsZWFyRXh0ZXJuYWxSZXN1bHRzXG4gIH0sIG5lc3RlZFJlc3VsdHMpKTtcbn1cblxuY2xhc3MgUmVzdWx0c1N0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlcyBhIHZhbGlkYXRpb24gcmVzdWx0LCBhbmQgaXRzIHJ1bGVzIGJ5IGl0cyBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3I+fSBydWxlc1xuICAgKiBAcGFyYW0ge1ZhbGlkYXRpb25SZXN1bHR9IHJlc3VsdFxuICAgKi9cblxuXG4gIHNldChwYXRoLCBydWxlcywgcmVzdWx0KSB7XG4gICAgdGhpcy5zdG9yYWdlLnNldChwYXRoLCB7XG4gICAgICBydWxlcyxcbiAgICAgIHJlc3VsdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3RvcmVkIGByZXN1bHRzYCBmb3IgdGhlIHByb3ZpZGVkIGBwYXRoYCBoYXZlIHRoZSBzYW1lIGBydWxlc2AgY29tcGFyZWQgdG8gJ3N0b3JlZFJ1bGVzJ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge09iamVjdDxOb3JtYWxpemVkVmFsaWRhdG9yPn0gcnVsZXNcbiAgICogQHBhcmFtIHtPYmplY3Q8Tm9ybWFsaXplZFZhbGlkYXRvcj59IHN0b3JlZFJ1bGVzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuXG5cbiAgY2hlY2tSdWxlc1ZhbGlkaXR5KHBhdGgsIHJ1bGVzLCBzdG9yZWRSdWxlcykge1xuICAgIGNvbnN0IHN0b3JlZFJ1bGVzS2V5cyA9IE9iamVjdC5rZXlzKHN0b3JlZFJ1bGVzKTtcbiAgICBjb25zdCBuZXdSdWxlc0tleXMgPSBPYmplY3Qua2V5cyhydWxlcyk7XG4gICAgaWYgKG5ld1J1bGVzS2V5cy5sZW5ndGggIT09IHN0b3JlZFJ1bGVzS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBoYXNBbGxWYWxpZGF0b3JzID0gbmV3UnVsZXNLZXlzLmV2ZXJ5KHJ1bGVLZXkgPT4gc3RvcmVkUnVsZXNLZXlzLmluY2x1ZGVzKHJ1bGVLZXkpKTtcbiAgICBpZiAoIWhhc0FsbFZhbGlkYXRvcnMpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gbmV3UnVsZXNLZXlzLmV2ZXJ5KHJ1bGVLZXkgPT4ge1xuICAgICAgaWYgKCFydWxlc1tydWxlS2V5XS4kcGFyYW1zKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhydWxlc1tydWxlS2V5XS4kcGFyYW1zKS5ldmVyeShwYXJhbUtleSA9PiB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byB1bndyYXAgYmVmb3JlIGNvbXBhcmluZ1xuICAgICAgICByZXR1cm4gdW5yZWYoc3RvcmVkUnVsZXNbcnVsZUtleV0uJHBhcmFtc1twYXJhbUtleV0pID09PSB1bnJlZihydWxlc1tydWxlS2V5XS4kcGFyYW1zW3BhcmFtS2V5XSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF0Y2hlZCByZXN1bHQgaWYgY2F0Y2hlIGlzIHZhbGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3I+fSBydWxlc1xuICAgKiBAcmV0dXJuIHt7JHBhcnRpYWw6IGJvb2xlYW4sICRkaXJ0eTogUmVmPEJvb2xlYW4+LCAkdW53YXRjaDogZnVuY3Rpb259fHVuZGVmaW5lZHxWYWxpZGF0aW9uUmVzdWx0fVxuICAgKi9cblxuXG4gIGdldChwYXRoLCBydWxlcykge1xuICAgIGNvbnN0IHN0b3JlZFJ1bGVSZXN1bHRQYWlyID0gdGhpcy5zdG9yYWdlLmdldChwYXRoKTtcbiAgICBpZiAoIXN0b3JlZFJ1bGVSZXN1bHRQYWlyKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHtcbiAgICAgIHJ1bGVzOiBzdG9yZWRSdWxlcyxcbiAgICAgIHJlc3VsdFxuICAgIH0gPSBzdG9yZWRSdWxlUmVzdWx0UGFpcjtcbiAgICBjb25zdCBpc1ZhbGlkQ2FjaGUgPSB0aGlzLmNoZWNrUnVsZXNWYWxpZGl0eShwYXRoLCBydWxlcywgc3RvcmVkUnVsZXMpO1xuICAgIGNvbnN0ICR1bndhdGNoID0gcmVzdWx0LiR1bndhdGNoID8gcmVzdWx0LiR1bndhdGNoIDogKCkgPT4gKHt9KTtcbiAgICBpZiAoIWlzVmFsaWRDYWNoZSkgcmV0dXJuIHtcbiAgICAgICRkaXJ0eTogcmVzdWx0LiRkaXJ0eSxcbiAgICAgICRwYXJ0aWFsOiB0cnVlLFxuICAgICAgJHVud2F0Y2hcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufVxuXG5jb25zdCBDb2xsZWN0RmxhZyA9IHtcbiAgQ09MTEVDVF9BTEw6IHRydWUsXG4gIENPTExFQ1RfTk9ORTogZmFsc2Vcbn07XG5jb25zdCBWdWVsaWRhdGVJbmplY3RDaGlsZFJlc3VsdHMgPSBTeW1ib2woJ3Z1ZWxpZGF0ZSNpbmplY3RDaGlpbGRSZXN1bHRzJyk7XG5jb25zdCBWdWVsaWRhdGVSZW1vdmVDaGlsZFJlc3VsdHMgPSBTeW1ib2woJ3Z1ZWxpZGF0ZSNyZW1vdmVDaGlpbGRSZXN1bHRzJyk7XG4vKipcbiAqIENyZWF0ZSBoZWxwZXJzIHRvIGNvbGxlY3QgdmFsaWRhdGlvbiBzdGF0ZSBmcm9tIGNoaWxkIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgQm9vbGVhbn0gcGFyYW1zLiRzY29wZSAtIFBhcmVudCBjb21wb25lbnQgc2NvcGVcbiAqIEByZXR1cm4ge3tzZW5kVmFsaWRhdGlvblJlc3VsdHNUb1BhcmVudDogZnVuY3Rpb25bXSwgY2hpbGRSZXN1bHRzOiBDb21wdXRlZFJlZjxPYmplY3Q+LCByZW1vdmVWYWxpZGF0aW9uUmVzdWx0c0Zyb21QYXJlbnQ6IGZ1bmN0aW9uW119fVxuICovXG5cbmZ1bmN0aW9uIG5lc3RlZFZhbGlkYXRpb25zKF9yZWYpIHtcbiAgbGV0IHtcbiAgICAkc2NvcGUsXG4gICAgaW5zdGFuY2VcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGNoaWxkUmVzdWx0c1JhdyA9IHt9O1xuICBjb25zdCBjaGlsZFJlc3VsdHNLZXlzID0gcmVmKFtdKTtcbiAgY29uc3QgY2hpbGRSZXN1bHRzID0gY29tcHV0ZWQoKCkgPT4gY2hpbGRSZXN1bHRzS2V5cy52YWx1ZS5yZWR1Y2UoKHJlc3VsdHMsIGtleSkgPT4ge1xuICAgIHJlc3VsdHNba2V5XSA9IHVucmVmKGNoaWxkUmVzdWx0c1Jhd1trZXldKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSwge30pKTtcbiAgLyoqXG4gICAqIEFsbG93cyBjaGlsZHJlbiB0byBzZW5kIHZhbGlkYXRpb24gZGF0YSB1cCB0byB0aGVpciBwYXJlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHRzIC0gdGhlIHJlc3VsdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MuJHJlZ2lzdGVyQXMgLSB0aGUgJHJlZ2lzdGVyZWRBcyBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBCb29sZWFufSBhcmdzLiRzY29wZSAtIHRoZSAkc2NvcGUga2V5XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluamVjdENoaWxkUmVzdWx0c0ludG9QYXJlbnQocmVzdWx0cywgX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgJHJlZ2lzdGVyQXM6IGtleSxcbiAgICAgICRzY29wZTogY2hpbGRTY29wZSxcbiAgICAgICRzdG9wUHJvcGFnYXRpb25cbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKCRzdG9wUHJvcGFnYXRpb24gfHwgJHNjb3BlID09PSBDb2xsZWN0RmxhZy5DT0xMRUNUX05PTkUgfHwgY2hpbGRTY29wZSA9PT0gQ29sbGVjdEZsYWcuQ09MTEVDVF9OT05FIHx8ICRzY29wZSAhPT0gQ29sbGVjdEZsYWcuQ09MTEVDVF9BTEwgJiYgJHNjb3BlICE9PSBjaGlsZFNjb3BlKSByZXR1cm47XG4gICAgY2hpbGRSZXN1bHRzUmF3W2tleV0gPSByZXN1bHRzO1xuICAgIGNoaWxkUmVzdWx0c0tleXMudmFsdWUucHVzaChrZXkpO1xuICB9IC8vIGNvbWJpbmUgd2l0aCBvdGhlciBgaW5qZWN0Q2hpbGRSZXN1bHRzSW50b1BhcmVudGAgZnJvbSB2dWVsaWRhdGUgaW5zdGFuY2VzIGluIHRoaXMgVnVlIGNvbXBvbmVudCBpbnN0YW5jZVxuXG5cbiAgaW5zdGFuY2UuX192dWVsaWRhdGVJbmplY3RJbnN0YW5jZXMgPSBbXS5jb25jYXQoaW5zdGFuY2UuX192dWVsaWRhdGVJbmplY3RJbnN0YW5jZXMgfHwgW10sIGluamVjdENoaWxkUmVzdWx0c0ludG9QYXJlbnQpO1xuICAvKipcbiAgICogQWxsb3dzIGNoaWxkcmVuIHRvIHJlbW92ZSB0aGUgdmFsaWRhdGlvbiBkYXRhIGZyb20gdGhlaXIgcGFyZW50LCBiZWZvcmUgZ2V0dGluZyBkZXN0cm95ZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB0aGUgcmVnaXN0ZXJlZEFzIGtleVxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlc3VsdHNGcm9tUGFyZW50KGtleSkge1xuICAgIC8vIHJlbW92ZSB0aGUga2V5XG4gICAgY2hpbGRSZXN1bHRzS2V5cy52YWx1ZSA9IGNoaWxkUmVzdWx0c0tleXMudmFsdWUuZmlsdGVyKGNoaWxkS2V5ID0+IGNoaWxkS2V5ICE9PSBrZXkpOyAvLyByZW1vdmUgdGhlIHN0b3JlZCBkYXRhIGZvciB0aGUga2V5XG5cbiAgICBkZWxldGUgY2hpbGRSZXN1bHRzUmF3W2tleV07XG4gIH0gLy8gY29tYmluZSB3aXRoIG90aGVyIGByZW1vdmVDaGlsZFJlc3VsdHNGcm9tUGFyZW50YCBmcm9tIHZ1ZWxpZGF0ZSBpbnN0YW5jZXMgaW4gdGhpcyBWdWUgY29tcG9uZW50IGluc3RhbmNlXG5cblxuICBpbnN0YW5jZS5fX3Z1ZWxpZGF0ZVJlbW92ZUluc3RhbmNlcyA9IFtdLmNvbmNhdChpbnN0YW5jZS5fX3Z1ZWxpZGF0ZVJlbW92ZUluc3RhbmNlcyB8fCBbXSwgcmVtb3ZlQ2hpbGRSZXN1bHRzRnJvbVBhcmVudCk7IC8vIGluamVjdCB0aGUgYGluamVjdENoaWxkUmVzdWx0c0ludG9QYXJlbnRgIG1ldGhvZCwgaW50byB0aGUgY3VycmVudCBzY29wZVxuXG4gIGNvbnN0IHNlbmRWYWxpZGF0aW9uUmVzdWx0c1RvUGFyZW50ID0gaW5qZWN0KFZ1ZWxpZGF0ZUluamVjdENoaWxkUmVzdWx0cywgW10pOyAvLyBwcm92aWRlIHRvIGFsbCBvZiBpdHMgY2hpbGRyZW4gdGhlIHNlbmQgcmVzdWx0cyB0byBwYXJlbnQgZnVuY3Rpb25cblxuICBwcm92aWRlKFZ1ZWxpZGF0ZUluamVjdENoaWxkUmVzdWx0cywgaW5zdGFuY2UuX192dWVsaWRhdGVJbmplY3RJbnN0YW5jZXMpO1xuICBjb25zdCByZW1vdmVWYWxpZGF0aW9uUmVzdWx0c0Zyb21QYXJlbnQgPSBpbmplY3QoVnVlbGlkYXRlUmVtb3ZlQ2hpbGRSZXN1bHRzLCBbXSk7IC8vIHByb3ZpZGUgdG8gYWxsIG9mIGl0cyBjaGlsZHJlbiB0aGUgcmVtb3ZlIHJlc3VsdHMgIGZ1bmN0aW9uXG5cbiAgcHJvdmlkZShWdWVsaWRhdGVSZW1vdmVDaGlsZFJlc3VsdHMsIGluc3RhbmNlLl9fdnVlbGlkYXRlUmVtb3ZlSW5zdGFuY2VzKTtcbiAgcmV0dXJuIHtcbiAgICBjaGlsZFJlc3VsdHMsXG4gICAgc2VuZFZhbGlkYXRpb25SZXN1bHRzVG9QYXJlbnQsXG4gICAgcmVtb3ZlVmFsaWRhdGlvblJlc3VsdHNGcm9tUGFyZW50XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHByb3h5IGZvciBpbnN0YW5jZSBwcm9wZXJ0eSBhY2Nlc3MuIEl0IG1ha2VzIGV2ZXJ5IHJlZmVyZW5jZVxuICogcmVhY3RpdmUgZm9yIHRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcmV0dXJuIHsqfENvbXB1dGVkUmVmPCo+fVxuICovXG5cbmZ1bmN0aW9uIENvbXB1dGVkUHJveHlGYWN0b3J5KHRhcmdldCkge1xuICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0W3Byb3BdID09PSAnb2JqZWN0JyA/IENvbXB1dGVkUHJveHlGYWN0b3J5KHRhcmdldFtwcm9wXSkgOiBjb21wdXRlZCgoKSA9PiB0YXJnZXRbcHJvcF0pO1xuICAgIH1cblxuICB9KTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBHbG9iYWxDb25maWdcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbJHJlZ2lzdGVyQXNdIC0gQ29uZmlnIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmcgfCBOdW1iZXIgfCBTeW1ib2x9IFskc2NvcGVdIC0gQSBzY29wZSB0byBsaW1pdCBjaGlsZCBjb21wb25lbnQgcmVnaXN0cmF0aW9uXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFskc3RvcFByb3BhZ2F0aW9uXSAtIFRlbGxzIGEgVnVlIGNvbXBvbmVudCB0byBzdG9wIHNlbmRpbmcgaXRzIHJlc3VsdHMgdXAgdG8gdGhlIHBhcmVudFxuICogQHByb3BlcnR5IHtSZWY8T2JqZWN0Pn0gWyRleHRlcm5hbFJlc3VsdHNdIC0gRXh0ZXJuYWwgZXJyb3IgbWVzc2FnZXMsIGxpa2UgZnJvbSBzZXJ2ZXIgdmFsaWRhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gWyRhdXRvRGlydHldIC0gU2hvdWxkIHRoZSBmb3JtIHdhdGNoIGZvciBzdGF0ZSBjaGFuZ2VkLCBhbmQgYXV0b21hdGljYWxseSBzZXQgYCRkaXJ0eWAgdG8gdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gWyRsYXp5XSAtIFNob3VsZCB0aGUgdmFsaWRhdGlvbnMgYmUgbGF6eSwgYW5kIHJ1biBvbmx5IGFmdGVyIHRoZXkgYXJlIGRpcnR5XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFskcmV3YXJkRWFybHldIC0gT25jZSB2YWxpZCwgcmUtcnVucyBwcm9wZXJ0eSB2YWxpZGF0b3JzIG9ubHkgb24gbWFudWFsIGNhbGxzIG9mICRjb21taXRcbiAqL1xuXG4vKipcbiAqIENvbXBvc2l0aW9uIEFQSSBjb21wYXRpYmxlIFZ1ZWxpZGF0ZVxuICogVXNlIGluc2lkZSB0aGUgYHNldHVwYCBsaWZlY3ljbGUgaG9va1xuICogQHBhcmFtIHtPYmplY3QgfCBHbG9iYWxDb25maWd9IFt2YWxpZGF0aW9uc10gLSBWYWxpZGF0aW9ucyBPYmplY3Qgb3IgdGhlIGdsb2JhbENvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhdGVdIC0gU3RhdGUgb2JqZWN0IC0gcmVxdWlyZWQgaWYgYHZhbGlkYXRpb25zYCBpcyBhIHZhbGlkYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtHbG9iYWxDb25maWd9IFtnbG9iYWxDb25maWddIC0gQ29uZmlnIE9iamVjdFxuICogQHJldHVybiB7Q29tcHV0ZWRSZWY8Kj59XG4gKi9cblxuZnVuY3Rpb24gdXNlVnVlbGlkYXRlKHZhbGlkYXRpb25zLCBzdGF0ZSkge1xuICBsZXQgZ2xvYmFsQ29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAvLyBpZiB3ZSBwYXNzIG9ubHkgb25lIGFyZ3VtZW50LCBpdHMgbW9zdCBwcm9iYWJseSB0aGUgZ2xvYmFsQ29uZmlnLlxuICAvLyBUaGlzIHVzZSBjYXNlIGlzIHNvIHBhcmVudHMgY2FuIGp1c3QgY29sbGVjdCByZXN1bHRzIG9mIGNoaWxkIGZvcm1zLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGdsb2JhbENvbmZpZyA9IHZhbGlkYXRpb25zO1xuICAgIHZhbGlkYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGV0IHtcbiAgICAkcmVnaXN0ZXJBcyxcbiAgICAkc2NvcGUgPSBDb2xsZWN0RmxhZy5DT0xMRUNUX0FMTCxcbiAgICAkc3RvcFByb3BhZ2F0aW9uLFxuICAgICRleHRlcm5hbFJlc3VsdHMsXG4gICAgY3VycmVudFZ1ZUluc3RhbmNlXG4gIH0gPSBnbG9iYWxDb25maWc7XG4gIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFZ1ZUluc3RhbmNlIHx8IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBjb25zdCBjb21wb25lbnRPcHRpb25zID0gaW5zdGFuY2UgPyBpc1Z1ZTMgPyBpbnN0YW5jZS50eXBlIDogaW5zdGFuY2UucHJveHkuJG9wdGlvbnMgOiB7fTsgLy8gaWYgdGhlcmUgaXMgbm8gcmVnaXN0cmF0aW9uIG5hbWUsIGFkZCBvbmUuXG5cbiAgaWYgKCEkcmVnaXN0ZXJBcyAmJiBpbnN0YW5jZSkge1xuICAgIC8vIE5PVEU6XG4gICAgLy8gLl91aWQgLy8gVnVlIDIueCBDb21wb3NpdGlvbi1BUEkgcGx1Z2luXG4gICAgLy8gLnVpZCAvLyBWdWUgMy4wXG4gICAgY29uc3QgdWlkID0gaW5zdGFuY2UudWlkIHx8IGluc3RhbmNlLl91aWQ7XG4gICAgJHJlZ2lzdGVyQXMgPSBgX3Z1ZWxpZGF0ZV8ke3VpZH1gO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGlvblJlc3VsdHMgPSByZWYoe30pO1xuICBjb25zdCByZXN1bHRzQ2FjaGUgPSBuZXcgUmVzdWx0c1N0b3JhZ2UoKTtcbiAgY29uc3Qge1xuICAgIGNoaWxkUmVzdWx0cyxcbiAgICBzZW5kVmFsaWRhdGlvblJlc3VsdHNUb1BhcmVudCxcbiAgICByZW1vdmVWYWxpZGF0aW9uUmVzdWx0c0Zyb21QYXJlbnRcbiAgfSA9IGluc3RhbmNlID8gbmVzdGVkVmFsaWRhdGlvbnMoe1xuICAgICRzY29wZSxcbiAgICBpbnN0YW5jZVxuICB9KSA6IHtcbiAgICBjaGlsZFJlc3VsdHM6IHJlZih7fSlcbiAgfTsgLy8gT3B0aW9ucyBBUElcblxuICBpZiAoIXZhbGlkYXRpb25zICYmIGNvbXBvbmVudE9wdGlvbnMudmFsaWRhdGlvbnMpIHtcbiAgICBjb25zdCBydWxlcyA9IGNvbXBvbmVudE9wdGlvbnMudmFsaWRhdGlvbnM7XG4gICAgc3RhdGUgPSByZWYoe30pO1xuICAgIG9uQmVmb3JlTW91bnQoKCkgPT4ge1xuICAgICAgLy8gRGVsYXkgYmluZGluZyBzdGF0ZSB0byB2YWxpZGF0aW9ucyBkZWZpbmVkIHdpdGggdGhlIE9wdGlvbnMgQVBJIHVudGlsIG1vdW50aW5nLCB3aGVuIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgYmVlbiBhdHRhY2hlZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLiBGcm9tIHRoYXQgcG9pbnQgb24gaXQgd2lsbCBiZSByZWFjdGl2ZS5cbiAgICAgIHN0YXRlLnZhbHVlID0gaW5zdGFuY2UucHJveHk7XG4gICAgICB3YXRjaCgoKSA9PiBpc0Z1bmN0aW9uKHJ1bGVzKSA/IHJ1bGVzLmNhbGwoc3RhdGUudmFsdWUsIG5ldyBDb21wdXRlZFByb3h5RmFjdG9yeShzdGF0ZS52YWx1ZSkpIDogcnVsZXMsIHZhbGlkYXRpb25zID0+IHtcbiAgICAgICAgdmFsaWRhdGlvblJlc3VsdHMudmFsdWUgPSBzZXRWYWxpZGF0aW9ucyh7XG4gICAgICAgICAgdmFsaWRhdGlvbnMsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgY2hpbGRSZXN1bHRzLFxuICAgICAgICAgIHJlc3VsdHNDYWNoZSxcbiAgICAgICAgICBnbG9iYWxDb25maWcsXG4gICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLnByb3h5LFxuICAgICAgICAgIGV4dGVybmFsUmVzdWx0czogJGV4dGVybmFsUmVzdWx0cyB8fCBpbnN0YW5jZS5wcm94eS52dWVsaWRhdGVFeHRlcm5hbFJlc3VsdHNcbiAgICAgICAgfSk7XG4gICAgICB9LCB7XG4gICAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZ2xvYmFsQ29uZmlnID0gY29tcG9uZW50T3B0aW9ucy52YWxpZGF0aW9uc0NvbmZpZyB8fCBnbG9iYWxDb25maWc7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmFsaWRhdGlvbnNXYXRjaFRhcmdldCA9IGlzUmVmKHZhbGlkYXRpb25zKSB8fCBpc1Byb3h5KHZhbGlkYXRpb25zKSA/IHZhbGlkYXRpb25zIC8vIHdyYXAgcGxhaW4gb2JqZWN0cyBpbiBhIHJlYWN0aXZlLCBzbyB3ZSBjYW4gdHJhY2sgY2hhbmdlcyBpZiB0aGV5IGhhdmUgY29tcHV0ZWQgaW4gdGhlbS5cbiAgICA6IHJlYWN0aXZlKHZhbGlkYXRpb25zIHx8IHt9KTtcbiAgICB3YXRjaCh2YWxpZGF0aW9uc1dhdGNoVGFyZ2V0LCBuZXdWYWxpZGF0aW9uUnVsZXMgPT4ge1xuICAgICAgdmFsaWRhdGlvblJlc3VsdHMudmFsdWUgPSBzZXRWYWxpZGF0aW9ucyh7XG4gICAgICAgIHZhbGlkYXRpb25zOiBuZXdWYWxpZGF0aW9uUnVsZXMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBjaGlsZFJlc3VsdHMsXG4gICAgICAgIHJlc3VsdHNDYWNoZSxcbiAgICAgICAgZ2xvYmFsQ29uZmlnLFxuICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UgPyBpbnN0YW5jZS5wcm94eSA6IHt9LFxuICAgICAgICBleHRlcm5hbFJlc3VsdHM6ICRleHRlcm5hbFJlc3VsdHNcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgLy8gc2VuZCBhbGwgdGhlIGRhdGEgdG8gdGhlIHBhcmVudCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIGluc2lkZSBzZXR1cC5cbiAgICBzZW5kVmFsaWRhdGlvblJlc3VsdHNUb1BhcmVudC5mb3JFYWNoKGYgPT4gZih2YWxpZGF0aW9uUmVzdWx0cywge1xuICAgICAgJHJlZ2lzdGVyQXMsXG4gICAgICAkc2NvcGUsXG4gICAgICAkc3RvcFByb3BhZ2F0aW9uXG4gICAgfSkpOyAvLyBiZWZvcmUgdGhpcyBjb21wb25lbnQgaXMgZGVzdHJveWVkLCByZW1vdmUgYWxsIHRoZSBkYXRhIGZyb20gdGhlIHBhcmVudC5cblxuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiByZW1vdmVWYWxpZGF0aW9uUmVzdWx0c0Zyb21QYXJlbnQuZm9yRWFjaChmID0+IGYoJHJlZ2lzdGVyQXMpKSk7XG4gIH1cblxuICByZXR1cm4gY29tcHV0ZWQoKCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB1bnJlZih2YWxpZGF0aW9uUmVzdWx0cy52YWx1ZSksIGNoaWxkUmVzdWx0cy52YWx1ZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb2xsZWN0RmxhZywgdXNlVnVlbGlkYXRlIGFzIGRlZmF1bHQsIHVzZVZ1ZWxpZGF0ZSB9O1xuIiwiaW1wb3J0IHsgdW5yZWYgfSBmcm9tICd2dWUtZGVtaSc7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICByZXR1cm4gbyAhPT0gbnVsbCAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdGFuZGFyZCBWYWxpZGF0b3JPYmplY3RcbiAqIFdyYXBzIGEgcGxhaW4gZnVuY3Rpb24gaW50byBhIFZhbGlkYXRvck9iamVjdFxuICogQHBhcmFtIHtOb3JtYWxpemVkVmFsaWRhdG9yfEZ1bmN0aW9ufSB2YWxpZGF0b3JcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsaWRhdG9yT2JqZWN0KHZhbGlkYXRvcikge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWxpZGF0b3IuJHZhbGlkYXRvcikgPyBPYmplY3QuYXNzaWduKHt9LCB2YWxpZGF0b3IpIDoge1xuICAgICR2YWxpZGF0b3I6IHZhbGlkYXRvclxuICB9O1xufVxuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiBpc0Z1bmN0aW9uKG9iamVjdC50aGVuKTtcbn1cbi8qKlxuICogVW53cmFwcyBhIFZhbGlkYXRvclJlc3BvbnNlIG9iamVjdCwgaW50byBhIGJvb2xlYW4uXG4gKiBAcGFyYW0ge1ZhbGlkYXRvclJlc3BvbnNlfSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gdW53cmFwVmFsaWRhdG9yUmVzcG9uc2UocmVzdWx0KSB7XG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JykgcmV0dXJuIHJlc3VsdC4kdmFsaWQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFVud3JhcHMgYSBgTm9ybWFsaXplZFZhbGlkYXRvcmAgb2JqZWN0LCByZXR1cm5pbmcgaXRzIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Tm9ybWFsaXplZFZhbGlkYXRvciB8IEZ1bmN0aW9ufSB2YWxpZGF0b3JcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3IodmFsaWRhdG9yKSB7XG4gIHJldHVybiB2YWxpZGF0b3IuJHZhbGlkYXRvciB8fCB2YWxpZGF0b3I7XG59XG5cbi8qKlxuICogQWxsb3dzIGF0dGFjaGluZyBwYXJhbWV0ZXJzIHRvIGEgdmFsaWRhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gJHBhcmFtc1xuICogQHBhcmFtIHtOb3JtYWxpemVkVmFsaWRhdG9yfEZ1bmN0aW9ufSAkdmFsaWRhdG9yXG4gKiBAcmV0dXJuIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIHdpdGhQYXJhbXMoJHBhcmFtcywgJHZhbGlkYXRvcikge1xuICBpZiAoIWlzT2JqZWN0KCRwYXJhbXMpKSB0aHJvdyBuZXcgRXJyb3IoYFtAdnVlbGlkYXRlL3ZhbGlkYXRvcnNdOiBGaXJzdCBwYXJhbWV0ZXIgdG8gXCJ3aXRoUGFyYW1zXCIgc2hvdWxkIGJlIGFuIG9iamVjdCwgcHJvdmlkZWQgJHt0eXBlb2YgJHBhcmFtc31gKTtcbiAgaWYgKCFpc09iamVjdCgkdmFsaWRhdG9yKSAmJiAhaXNGdW5jdGlvbigkdmFsaWRhdG9yKSkgdGhyb3cgbmV3IEVycm9yKGBbQHZ1ZWxpZGF0ZS92YWxpZGF0b3JzXTogVmFsaWRhdG9yIG11c3QgYmUgYSBmdW5jdGlvbiBvciBvYmplY3Qgd2l0aCAkdmFsaWRhdG9yIHBhcmFtZXRlcmApO1xuICBjb25zdCB2YWxpZGF0b3JPYmogPSBub3JtYWxpemVWYWxpZGF0b3JPYmplY3QoJHZhbGlkYXRvcik7XG4gIHZhbGlkYXRvck9iai4kcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsaWRhdG9yT2JqLiRwYXJhbXMgfHwge30sICRwYXJhbXMpO1xuICByZXR1cm4gdmFsaWRhdG9yT2JqO1xufVxuXG4vKipcbiAqIEBjYWxsYmFjayBNZXNzYWdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqIEByZXR1cm4gU3RyaW5nXG4gKi9cblxuLyoqXG4gKiBBdHRhY2hlcyBhIG1lc3NhZ2UgdG8gYSB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrIHwgU3RyaW5nfSAkbWVzc2FnZVxuICogQHBhcmFtIHtOb3JtYWxpemVkVmFsaWRhdG9yfEZ1bmN0aW9ufSAkdmFsaWRhdG9yXG4gKiBAcmV0dXJuIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIHdpdGhNZXNzYWdlKCRtZXNzYWdlLCAkdmFsaWRhdG9yKSB7XG4gIGlmICghaXNGdW5jdGlvbigkbWVzc2FnZSkgJiYgdHlwZW9mIHVucmVmKCRtZXNzYWdlKSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihgW0B2dWVsaWRhdGUvdmFsaWRhdG9yc106IEZpcnN0IHBhcmFtZXRlciB0byBcIndpdGhNZXNzYWdlXCIgc2hvdWxkIGJlIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZywgcHJvdmlkZWQgJHt0eXBlb2YgJG1lc3NhZ2V9YCk7XG4gIGlmICghaXNPYmplY3QoJHZhbGlkYXRvcikgJiYgIWlzRnVuY3Rpb24oJHZhbGlkYXRvcikpIHRocm93IG5ldyBFcnJvcihgW0B2dWVsaWRhdGUvdmFsaWRhdG9yc106IFZhbGlkYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24gb3Igb2JqZWN0IHdpdGggJHZhbGlkYXRvciBwYXJhbWV0ZXJgKTtcbiAgY29uc3QgdmFsaWRhdG9yT2JqID0gbm9ybWFsaXplVmFsaWRhdG9yT2JqZWN0KCR2YWxpZGF0b3IpO1xuICB2YWxpZGF0b3JPYmouJG1lc3NhZ2UgPSAkbWVzc2FnZTtcbiAgcmV0dXJuIHZhbGlkYXRvck9iajtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKik6IFByb21pc2U8Ym9vbGVhbnxWYWxpZGF0b3JSZXNwb25zZT59IGFzeW5jVmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVmPCo+W118ZnVuY3Rpb24oKik6ICp9IHdhdGNoVGFyZ2V0c1xuICovXG5cbi8qKlxuICogV3JhcHMgdmFsaWRhdG9ycyB0aGF0IHJldHVybnMgYSBQcm9taXNlLlxuICogQHBhcmFtIHthc3luY1ZhbGlkYXRvcn0gJHZhbGlkYXRvclxuICogQHBhcmFtIHt3YXRjaFRhcmdldHN9ICR3YXRjaFRhcmdldHNcbiAqIEByZXR1cm4ge3skYXN5bmM6IGJvb2xlYW4sICR2YWxpZGF0b3I6IGFzeW5jVmFsaWRhdG9yLCAkd2F0Y2hUYXJnZXRzOiB3YXRjaFRhcmdldHN9fVxuICovXG5cbmZ1bmN0aW9uIHdpdGhBc3luYygkdmFsaWRhdG9yLCAkd2F0Y2hUYXJnZXRzID0gW10pIHtcbiAgY29uc3QgdmFsaWRhdG9yT2JqID0gbm9ybWFsaXplVmFsaWRhdG9yT2JqZWN0KCR2YWxpZGF0b3IpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdmFsaWRhdG9yT2JqLCB7XG4gICAgJGFzeW5jOiB0cnVlLFxuICAgICR3YXRjaFRhcmdldHNcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2godmFsaWRhdG9ycykge1xuICByZXR1cm4ge1xuICAgICR2YWxpZGF0b3IoY29sbGVjdGlvbiwgLi4ub3RoZXJzKSB7XG4gICAgICAvLyBnbyBvdmVyIHRoZSBjb2xsZWN0aW9uLiBJdCBjYW4gYmUgYSByZWYgYXMgd2VsbC5cbiAgICAgIHJldHVybiB1bnJlZihjb2xsZWN0aW9uKS5yZWR1Y2UoKHByZXZpb3VzLCBjb2xsZWN0aW9uSXRlbSkgPT4ge1xuICAgICAgICAvLyBnbyBvdmVyIGVhY2ggcHJvcGVydHlcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbkVudHJ5UmVzdWx0ID0gT2JqZWN0LmVudHJpZXMoY29sbGVjdGlvbkl0ZW0pLnJlZHVjZSgoYWxsLCBbcHJvcGVydHksICRtb2RlbF0pID0+IHtcbiAgICAgICAgICAvLyBnZXQgdGhlIHZhbGlkYXRvcnMgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICBjb25zdCBpbm5lclZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzW3Byb3BlcnR5XSB8fCB7fTsgLy8gZ28gb3ZlciBlYWNoIHZhbGlkYXRvciBhbmQgcnVuIGl0XG5cbiAgICAgICAgICBjb25zdCBwcm9wZXJ0eVJlc3VsdCA9IE9iamVjdC5lbnRyaWVzKGlubmVyVmFsaWRhdG9ycykucmVkdWNlKChhbGwsIFt2YWxpZGF0b3JOYW1lLCBjdXJyZW50VmFsaWRhdG9yXSkgPT4ge1xuICAgICAgICAgICAgLy8gZXh0cmFjdCB0aGUgdmFsaWRhdG9yLiBTdXBwb3J0cyBzaW1wbGUgYW5kIGV4dGVuZGVkIHZhbGlkYXRvcnMuXG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0b3JGdW5jdGlvbiA9IHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3IoY3VycmVudFZhbGlkYXRvcik7IC8vIENhbGwgdGhlIHZhbGlkYXRvciwgcGFzc2luZyB0aGUgVk0gYXMgdGhpcywgdGhlIHZhbHVlLCBjdXJyZW50IGl0ZXJhdGVkIG9iamVjdCBhbmQgdGhlIHJlc3QuXG5cbiAgICAgICAgICAgIGNvbnN0ICRyZXNwb25zZSA9IHZhbGlkYXRvckZ1bmN0aW9uLmNhbGwodGhpcywgJG1vZGVsLCBjb2xsZWN0aW9uSXRlbSwgLi4ub3RoZXJzKTsgLy8gZXh0cmFjdCB0aGUgdmFsaWQgZnJvbSB0aGUgcmVzdWx0XG5cbiAgICAgICAgICAgIGNvbnN0ICR2YWxpZCA9IHVud3JhcFZhbGlkYXRvclJlc3BvbnNlKCRyZXNwb25zZSk7IC8vIHN0b3JlIHRoZSBlbnRpcmUgcmVzcG9uc2UgZm9yIGxhdGVyXG5cbiAgICAgICAgICAgIGFsbC4kZGF0YVt2YWxpZGF0b3JOYW1lXSA9ICRyZXNwb25zZTtcbiAgICAgICAgICAgIGFsbC4kZGF0YS4kaW52YWxpZCA9ICEkdmFsaWQgfHwgISFhbGwuJGRhdGEuJGludmFsaWQ7XG4gICAgICAgICAgICBhbGwuJGRhdGEuJGVycm9yID0gYWxsLiRkYXRhLiRpbnZhbGlkOyAvLyBpZiBub3QgdmFsaWQsIGdldCB0aGUgJG1lc3NhZ2VcblxuICAgICAgICAgICAgaWYgKCEkdmFsaWQpIHtcbiAgICAgICAgICAgICAgbGV0ICRtZXNzYWdlID0gY3VycmVudFZhbGlkYXRvci4kbWVzc2FnZSB8fCAnJztcbiAgICAgICAgICAgICAgY29uc3QgJHBhcmFtcyA9IGN1cnJlbnRWYWxpZGF0b3IuJHBhcmFtcyB8fCB7fTsgLy8gSWYgJG1lc3NhZ2UgaXMgYSBmdW5jdGlvbiwgd2UgY2FsbCBpdCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBwYXJhbWV0ZXJzXG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiAkbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICRtZXNzYWdlID0gJG1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgJHBlbmRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgJGludmFsaWQ6ICEkdmFsaWQsXG4gICAgICAgICAgICAgICAgICAkcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgJG1vZGVsLFxuICAgICAgICAgICAgICAgICAgJHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gLy8gc2F2ZSB0aGUgZXJyb3Igb2JqZWN0XG5cblxuICAgICAgICAgICAgICBhbGwuJGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAkcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICRtZXNzYWdlLFxuICAgICAgICAgICAgICAgICRwYXJhbXMsXG4gICAgICAgICAgICAgICAgJHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICRtb2RlbCxcbiAgICAgICAgICAgICAgICAkcGVuZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJHZhbGlkYXRvcjogdmFsaWRhdG9yTmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgJHZhbGlkOiBhbGwuJHZhbGlkICYmICR2YWxpZCxcbiAgICAgICAgICAgICAgJGRhdGE6IGFsbC4kZGF0YSxcbiAgICAgICAgICAgICAgJGVycm9yczogYWxsLiRlcnJvcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgJHZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgJGRhdGE6IHt9LFxuICAgICAgICAgICAgJGVycm9yczogW11cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhbGwuJGRhdGFbcHJvcGVydHldID0gcHJvcGVydHlSZXN1bHQuJGRhdGE7XG4gICAgICAgICAgYWxsLiRlcnJvcnNbcHJvcGVydHldID0gcHJvcGVydHlSZXN1bHQuJGVycm9ycztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJHZhbGlkOiBhbGwuJHZhbGlkICYmIHByb3BlcnR5UmVzdWx0LiR2YWxpZCxcbiAgICAgICAgICAgICRkYXRhOiBhbGwuJGRhdGEsXG4gICAgICAgICAgICAkZXJyb3JzOiBhbGwuJGVycm9yc1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAkdmFsaWQ6IHRydWUsXG4gICAgICAgICAgJGRhdGE6IHt9LFxuICAgICAgICAgICRlcnJvcnM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICR2YWxpZDogcHJldmlvdXMuJHZhbGlkICYmIGNvbGxlY3Rpb25FbnRyeVJlc3VsdC4kdmFsaWQsXG4gICAgICAgICAgJGRhdGE6IHByZXZpb3VzLiRkYXRhLmNvbmNhdChjb2xsZWN0aW9uRW50cnlSZXN1bHQuJGRhdGEpLFxuICAgICAgICAgICRlcnJvcnM6IHByZXZpb3VzLiRlcnJvcnMuY29uY2F0KGNvbGxlY3Rpb25FbnRyeVJlc3VsdC4kZXJyb3JzKVxuICAgICAgICB9O1xuICAgICAgfSwge1xuICAgICAgICAkdmFsaWQ6IHRydWUsXG4gICAgICAgICRkYXRhOiBbXSxcbiAgICAgICAgJGVycm9yczogW11cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBjb2xsZWN0IGFsbCB0aGUgdmFsaWRhdGlvbiBlcnJvcnMgaW50byBhIDIgZGltZW5zaW9uYWwgYXJyYXksIGZvciBlYWNoIGVudHJ5IGluIHRoZSBjb2xsZWN0aW9uLCB5b3UgaGF2ZSBhbiBhcnJheSBvZiBlcnJvciBtZXNzYWdlcy5cbiAgICAkbWVzc2FnZTogKHtcbiAgICAgICRyZXNwb25zZVxuICAgIH0pID0+ICRyZXNwb25zZSA/ICRyZXNwb25zZS4kZXJyb3JzLm1hcChjb250ZXh0ID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGNvbnRleHQpLm1hcChlcnJvcnMgPT4gZXJyb3JzLm1hcChlcnJvciA9PiBlcnJvci4kbWVzc2FnZSkpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKTtcbiAgICB9KSA6IFtdXG4gIH07XG59XG5cbi8vIFwicmVxdWlyZWRcIiBjb3JlLCB1c2VkIGluIGFsbW9zdCBldmVyeSB2YWxpZGF0b3IgdG8gYWxsb3cgZW1wdHkgdmFsdWVzXG5jb25zdCByZXEgPSB2YWx1ZSA9PiB7XG4gIHZhbHVlID0gdW5yZWYodmFsdWUpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiAhIXZhbHVlLmxlbmd0aDtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAvLyBpbnZhbGlkIGRhdGUgd29uJ3QgcGFzc1xuICAgIHJldHVybiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChsZXQgXyBpbiB2YWx1ZSkgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISFTdHJpbmcodmFsdWUpLmxlbmd0aDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhbiBhcmJpdHJhcnkgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5jb25zdCBsZW4gPSB2YWx1ZSA9PiB7XG4gIHZhbHVlID0gdW5yZWYodmFsdWUpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZS5sZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcodmFsdWUpLmxlbmd0aDtcbn07XG4vKipcbiAqIFJlZ2V4IGJhc2VkIHZhbGlkYXRvciB0ZW1wbGF0ZVxuICogQHBhcmFtIHtSZWdFeHB9IGV4cHJcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCo9KTogYm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiByZWdleChleHByKSB7XG4gIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgdmFsdWUgPSB1bnJlZih2YWx1ZSk7XG4gICAgcmV0dXJuICFyZXEodmFsdWUpIHx8IGV4cHIudGVzdCh2YWx1ZSk7XG4gIH07XG59XG5cbnZhciBjb21tb24gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgd2l0aFBhcmFtczogd2l0aFBhcmFtcyxcbiAgd2l0aE1lc3NhZ2U6IHdpdGhNZXNzYWdlLFxuICB3aXRoQXN5bmM6IHdpdGhBc3luYyxcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgcmVxOiByZXEsXG4gIGxlbjogbGVuLFxuICByZWdleDogcmVnZXgsXG4gIHVud3JhcDogdW5yZWYsXG4gIHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3I6IHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3IsXG4gIHVud3JhcFZhbGlkYXRvclJlc3BvbnNlOiB1bndyYXBWYWxpZGF0b3JSZXNwb25zZSxcbiAgbm9ybWFsaXplVmFsaWRhdG9yT2JqZWN0OiBub3JtYWxpemVWYWxpZGF0b3JPYmplY3Rcbn0pO1xuXG52YXIgYWxwaGEkMSA9IHJlZ2V4KC9eW2EtekEtWl0qJC8pO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHZhbHVlIGlzIGFscGhhYmV0aWNhbCBzdHJpbmcuXG4gKiBAdHlwZSB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG52YXIgYWxwaGEgPSB7XG4gICR2YWxpZGF0b3I6IGFscGhhJDEsXG4gICRtZXNzYWdlOiAnVGhlIHZhbHVlIGlzIG5vdCBhbHBoYWJldGljYWwnLFxuICAkcGFyYW1zOiB7XG4gICAgdHlwZTogJ2FscGhhJ1xuICB9XG59O1xuXG52YXIgYWxwaGFOdW0kMSA9IHJlZ2V4KC9eW2EtekEtWjAtOV0qJC8pO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHZhbHVlIGlzIGFscGhhLW51bWVyaWMgc3RyaW5nLlxuICogQHR5cGUge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxudmFyIGFscGhhTnVtID0ge1xuICAkdmFsaWRhdG9yOiBhbHBoYU51bSQxLFxuICAkbWVzc2FnZTogJ1RoZSB2YWx1ZSBtdXN0IGJlIGFscGhhLW51bWVyaWMnLFxuICAkcGFyYW1zOiB7XG4gICAgdHlwZTogJ2FscGhhTnVtJ1xuICB9XG59O1xuXG52YXIgbnVtZXJpYyQxID0gcmVnZXgoL15cXGQqKFxcLlxcZCspPyQvKTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgdmFsdWUgaXMgbnVtZXJpYy5cbiAqIEB0eXBlIE5vcm1hbGl6ZWRWYWxpZGF0b3JcbiAqL1xuXG52YXIgbnVtZXJpYyA9IHtcbiAgJHZhbGlkYXRvcjogbnVtZXJpYyQxLFxuICAkbWVzc2FnZTogJ1ZhbHVlIG11c3QgYmUgbnVtZXJpYycsXG4gICRwYXJhbXM6IHtcbiAgICB0eXBlOiAnbnVtZXJpYydcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIG51bWVyaWMgdmFsdWUgaXMgYmV0d2VlbiB0d28gdmFsdWVzLlxuICogQHBhcmFtIHtSZWY8TnVtYmVyPiB8IE51bWJlcn0gbWluXG4gKiBAcGFyYW0ge1JlZjxOdW1iZXI+IHwgTnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCo9KTogYm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBiZXR3ZWVuJDEgKG1pbiwgbWF4KSB7XG4gIHJldHVybiB2YWx1ZSA9PiAhcmVxKHZhbHVlKSB8fCAoIS9cXHMvLnRlc3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgJiYgK3VucmVmKG1pbikgPD0gK3ZhbHVlICYmICt1bnJlZihtYXgpID49ICt2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBiZXR3ZWVuIHR3byB2YWx1ZXMuXG4gKiBAcGFyYW0ge1JlZjxOdW1iZXI+IHwgTnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7UmVmPE51bWJlcj4gfCBOdW1iZXJ9IG1heFxuICogQHJldHVybiB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiBiZXR3ZWVuIChtaW4sIG1heCkge1xuICByZXR1cm4ge1xuICAgICR2YWxpZGF0b3I6IGJldHdlZW4kMShtaW4sIG1heCksXG4gICAgJG1lc3NhZ2U6ICh7XG4gICAgICAkcGFyYW1zXG4gICAgfSkgPT4gYFRoZSB2YWx1ZSBtdXN0IGJlIGJldHdlZW4gJHskcGFyYW1zLm1pbn0gYW5kICR7JHBhcmFtcy5tYXh9YCxcbiAgICAkcGFyYW1zOiB7XG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgICB0eXBlOiAnYmV0d2VlbidcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/OltBLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bQS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSp8XCIoPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2ZdfFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKlwiKUAoPzooPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XXsyLH0oPzpbYS16MC05LV0qW2EtejAtOV0pP3xcXFsoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldP3xbYS16MC05LV0qW2EtejAtOV06KD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4NWFcXHg1My1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKylcXF0pJC9pO1xudmFyIGVtYWlsJDEgPSByZWdleChlbWFpbFJlZ2V4KTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBpZiB2YWx1ZSBpcyBhbiBlbWFpbC5cbiAqIEB0eXBlIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbnZhciBlbWFpbCA9IHtcbiAgJHZhbGlkYXRvcjogZW1haWwkMSxcbiAgJG1lc3NhZ2U6ICdWYWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdlbWFpbCdcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhbiBJUCBBZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlwQWRkcmVzcyQxICh2YWx1ZSkge1xuICBpZiAoIXJlcSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbmliYmxlcyA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gIHJldHVybiBuaWJibGVzLmxlbmd0aCA9PT0gNCAmJiBuaWJibGVzLmV2ZXJ5KG5pYmJsZVZhbGlkKTtcbn1cblxuY29uc3QgbmliYmxlVmFsaWQgPSBuaWJibGUgPT4ge1xuICBpZiAobmliYmxlLmxlbmd0aCA+IDMgfHwgbmliYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuaWJibGVbMF0gPT09ICcwJyAmJiBuaWJibGUgIT09ICcwJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghbmliYmxlLm1hdGNoKC9eXFxkKyQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG51bWVyaWMgPSArbmliYmxlIHwgMDtcbiAgcmV0dXJuIG51bWVyaWMgPj0gMCAmJiBudW1lcmljIDw9IDI1NTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgaWYgdmFsdWUgaXMgYW4gaXBBZGRyZXNzIHN0cmluZy5cbiAqIEB0eXBlIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbnZhciBpcEFkZHJlc3MgPSB7XG4gICR2YWxpZGF0b3I6IGlwQWRkcmVzcyQxLFxuICAkbWVzc2FnZTogJ1RoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBJUCBhZGRyZXNzJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdpcEFkZHJlc3MnXG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYSBwcm9wZXJseSBmb3JtYXR0ZWQgTWFjIEFkZHJlc3MuXG4gKiBAcGFyYW0ge1N0cmluZyB8IFJlZjxTdHJpbmc+fSBbc2VwYXJhdG9yXVxuICogQHJldHVybnMge2Z1bmN0aW9uKCopOiBib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIG1hY0FkZHJlc3MkMSAoc2VwYXJhdG9yID0gJzonKSB7XG4gIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgc2VwYXJhdG9yID0gdW5yZWYoc2VwYXJhdG9yKTtcblxuICAgIGlmICghcmVxKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0cyA9IHR5cGVvZiBzZXBhcmF0b3IgPT09ICdzdHJpbmcnICYmIHNlcGFyYXRvciAhPT0gJycgPyB2YWx1ZS5zcGxpdChzZXBhcmF0b3IpIDogdmFsdWUubGVuZ3RoID09PSAxMiB8fCB2YWx1ZS5sZW5ndGggPT09IDE2ID8gdmFsdWUubWF0Y2goLy57Mn0vZykgOiBudWxsO1xuICAgIHJldHVybiBwYXJ0cyAhPT0gbnVsbCAmJiAocGFydHMubGVuZ3RoID09PSA2IHx8IHBhcnRzLmxlbmd0aCA9PT0gOCkgJiYgcGFydHMuZXZlcnkoaGV4VmFsaWQpO1xuICB9O1xufVxuXG5jb25zdCBoZXhWYWxpZCA9IGhleCA9PiBoZXgudG9Mb3dlckNhc2UoKS5tYXRjaCgvXlswLTlhLWZdezJ9JC8pO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHZhbHVlIGlzIGEgdmFsaWQgTWFjIEFkZHJlc3Mgc3RyaW5nLlxuICogQHJldHVybnMge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxuZnVuY3Rpb24gbWFjQWRkcmVzcyAoc2VwYXJhdG9yKSB7XG4gIHJldHVybiB7XG4gICAgJHZhbGlkYXRvcjogbWFjQWRkcmVzcyQxKHNlcGFyYXRvciksXG4gICAgJG1lc3NhZ2U6ICdUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgTUFDIEFkZHJlc3MnLFxuICAgICRwYXJhbXM6IHtcbiAgICAgIHR5cGU6ICdtYWNBZGRyZXNzJ1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwcm92aWRlZCB2YWx1ZSBoYXMgYSBtYXhpbXVtIGxlbmd0aFxuICogQHBhcmFtIHtOdW1iZXIgfCBSZWY8TnVtYmVyPn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oQXJyYXl8T2JqZWN0fFN0cmluZyk6IGJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gbWF4TGVuZ3RoJDEgKGxlbmd0aCkge1xuICByZXR1cm4gdmFsdWUgPT4gIXJlcSh2YWx1ZSkgfHwgbGVuKHZhbHVlKSA8PSB1bnJlZihsZW5ndGgpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBtYXggbGVuZ3RoIG9mIGEgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFxuICogQHJldHVybiB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiBtYXhMZW5ndGggKG1heCkge1xuICByZXR1cm4ge1xuICAgICR2YWxpZGF0b3I6IG1heExlbmd0aCQxKG1heCksXG4gICAgJG1lc3NhZ2U6ICh7XG4gICAgICAkcGFyYW1zXG4gICAgfSkgPT4gYFRoZSBtYXhpbXVtIGxlbmd0aCBhbGxvd2VkIGlzICR7JHBhcmFtcy5tYXh9YCxcbiAgICAkcGFyYW1zOiB7XG4gICAgICBtYXgsXG4gICAgICB0eXBlOiAnbWF4TGVuZ3RoJ1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqIEBwYXJhbSB7TnVtYmVyIHwgUmVmPE51bWJlcj59IGxlbmd0aFxuICogQHJldHVybnMge2Z1bmN0aW9uKEFycmF5fE9iamVjdHxTdHJpbmcpOiBib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIG1pbkxlbmd0aCQxIChsZW5ndGgpIHtcbiAgcmV0dXJuIHZhbHVlID0+ICFyZXEodmFsdWUpIHx8IGxlbih2YWx1ZSkgPj0gdW5yZWYobGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqIEBwYXJhbSB7TnVtYmVyIHwgUmVmPE51bWJlcj59IG1pblxuICogQHJldHVybnMge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxuZnVuY3Rpb24gbWluTGVuZ3RoIChtaW4pIHtcbiAgcmV0dXJuIHtcbiAgICAkdmFsaWRhdG9yOiBtaW5MZW5ndGgkMShtaW4pLFxuICAgICRtZXNzYWdlOiAoe1xuICAgICAgJHBhcmFtc1xuICAgIH0pID0+IGBUaGlzIGZpZWxkIHNob3VsZCBiZSBhdCBsZWFzdCAkeyRwYXJhbXMubWlufSBsb25nYCxcbiAgICAkcGFyYW1zOiB7XG4gICAgICBtaW4sXG4gICAgICB0eXBlOiAnbWluTGVuZ3RoJ1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgaWYgYSB2YWx1ZSBpcyBlbXB0eS5cbiAqIEBwYXJhbSB7U3RyaW5nIHwgQXJyYXkgfCBEYXRlIHwgT2JqZWN0fSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gcmVxdWlyZWQkMSAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiByZXEodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgZW1wdHkgb3Igbm90LlxuICogQHR5cGUge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxudmFyIHJlcXVpcmVkID0ge1xuICAkdmFsaWRhdG9yOiByZXF1aXJlZCQxLFxuICAkbWVzc2FnZTogJ1ZhbHVlIGlzIHJlcXVpcmVkJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdyZXF1aXJlZCdcbiAgfVxufTtcblxuY29uc3QgdmFsaWRhdGUkMSA9IChwcm9wLCB2YWwpID0+IHByb3AgPyByZXEodmFsKSA6IHRydWU7XG4vKipcbiAqIFJldHVybnMgcmVxdWlyZWQgaWYgdGhlIHBhc3NlZCBwcm9wZXJ0eSBpcyB0cnV0aHlcbiAqIEBwYXJhbSB7Qm9vbGVhbiB8IFN0cmluZyB8IGZ1bmN0aW9uKGFueSk6IEJvb2xlYW4gfCBSZWY8c3RyaW5nIHwgYm9vbGVhbj59IHByb3BPckZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbih2YWx1ZTogKiwgcGFyZW50Vk06IG9iamVjdCk6IEJvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiByZXF1aXJlZElmJDEocHJvcE9yRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgcGFyZW50Vk0pIHtcbiAgICBpZiAodHlwZW9mIHByb3BPckZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUkMSh1bnJlZihwcm9wT3JGdW5jdGlvbiksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBwcm9wT3JGdW5jdGlvbi5jYWxsKHRoaXMsIHZhbHVlLCBwYXJlbnRWTSk7XG4gICAgcmV0dXJuIHZhbGlkYXRlJDEocmVzdWx0LCB2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyByZXF1aXJlZCBpZiB0aGUgcGFzc2VkIHByb3BlcnR5IGlzIHRydXRoeVxuICogQHBhcmFtIHtCb29sZWFuIHwgU3RyaW5nIHwgZnVuY3Rpb24oKTogKEJvb2xlYW4gfCBQcm9taXNlPGJvb2xlYW4+KX0gcHJvcFxuICogQHJldHVybiB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiByZXF1aXJlZElmIChwcm9wKSB7XG4gIHJldHVybiB7XG4gICAgJHZhbGlkYXRvcjogcmVxdWlyZWRJZiQxKHByb3ApLFxuICAgICRtZXNzYWdlOiAnVGhlIHZhbHVlIGlzIHJlcXVpcmVkJyxcbiAgICAkcGFyYW1zOiB7XG4gICAgICB0eXBlOiAncmVxdWlyZWRJZicsXG4gICAgICBwcm9wXG4gICAgfVxuICB9O1xufVxuXG5jb25zdCB2YWxpZGF0ZSA9IChwcm9wLCB2YWwpID0+ICFwcm9wID8gcmVxKHZhbCkgOiB0cnVlO1xuLyoqXG4gKiBSZXR1cm5zIHJlcXVpcmVkIGlmIHRoZSBwYXNzZWQgcHJvcGVydHkgaXMgZmFsc3kuXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBTdHJpbmcgfCBmdW5jdGlvbihhbnkpOiBCb29sZWFuIHwgUmVmPHN0cmluZyB8IGJvb2xlYW4+fSBwcm9wT3JGdW5jdGlvblxuICogQHJldHVybiB7ZnVuY3Rpb24odmFsdWU6ICosIHBhcmVudFZNOiBvYmplY3QpOiBCb29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gcmVxdWlyZWRVbmxlc3MkMShwcm9wT3JGdW5jdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBwYXJlbnRWTSkge1xuICAgIGlmICh0eXBlb2YgcHJvcE9yRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZSh1bnJlZihwcm9wT3JGdW5jdGlvbiksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBwcm9wT3JGdW5jdGlvbi5jYWxsKHRoaXMsIHZhbHVlLCBwYXJlbnRWTSk7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHJlc3VsdCwgdmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgcmVxdWlyZWQgdW5sZXNzIHRoZSBwYXNzZWQgcHJvcGVydHkgaXMgdHJ1dGh5XG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBTdHJpbmcgfCBmdW5jdGlvbigpOiAoQm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj4pfSBwcm9wXG4gKiBAcmV0dXJuIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIHJlcXVpcmVkVW5sZXNzIChwcm9wKSB7XG4gIHJldHVybiB7XG4gICAgJHZhbGlkYXRvcjogcmVxdWlyZWRVbmxlc3MkMShwcm9wKSxcbiAgICAkbWVzc2FnZTogJ1RoZSB2YWx1ZSBpcyByZXF1aXJlZCcsXG4gICAgJHBhcmFtczoge1xuICAgICAgdHlwZTogJ3JlcXVpcmVkVW5sZXNzJyxcbiAgICAgIHByb3BcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICogQHBhcmFtIHsqfSBlcXVhbFRvXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigqPSk6IGJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gc2FtZUFzJDEgKGVxdWFsVG8pIHtcbiAgcmV0dXJuIHZhbHVlID0+IHVucmVmKHZhbHVlKSA9PT0gdW5yZWYoZXF1YWxUbyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgaWRlbnRpY2FsXG4gKiBAcGFyYW0geyp9IGVxdWFsVG9cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3RoZXJOYW1lXVxuICogQHJldHVybiB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiBzYW1lQXMgKGVxdWFsVG8sIG90aGVyTmFtZSA9ICdvdGhlcicpIHtcbiAgcmV0dXJuIHtcbiAgICAkdmFsaWRhdG9yOiBzYW1lQXMkMShlcXVhbFRvKSxcbiAgICAkbWVzc2FnZTogKHtcbiAgICAgICRwYXJhbXNcbiAgICB9KSA9PiBgVGhlIHZhbHVlIG11c3QgYmUgZXF1YWwgdG8gdGhlICR7b3RoZXJOYW1lfSB2YWx1ZWAsXG4gICAgJHBhcmFtczoge1xuICAgICAgZXF1YWxUbyxcbiAgICAgIG90aGVyTmFtZSxcbiAgICAgIHR5cGU6ICdzYW1lQXMnXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlZ2V4IHRha2VuIGZyb20ge0BsaW5rIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0fVxuICovXG5cbmNvbnN0IHVybFJlZ2V4ID0gL14oPzooPzooPzpodHRwcz98ZnRwKTopP1xcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ISg/OjEwfDEyNykoPzpcXC5cXGR7MSwzfSl7M30pKD8hKD86MTY5XFwuMjU0fDE5MlxcLjE2OCkoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtejAtOVxcdTAwYTEtXFx1ZmZmZl1bYS16MC05XFx1MDBhMS1cXHVmZmZmXy1dezAsNjJ9KT9bYS16MC05XFx1MDBhMS1cXHVmZmZmXVxcLikrKD86W2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9XFwuPykpKD86OlxcZHsyLDV9KT8oPzpbLz8jXVxcUyopPyQvaTtcbnZhciB1cmwkMSA9IHJlZ2V4KHVybFJlZ2V4KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgdXJsXG4gKiBAdHlwZSB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG52YXIgdXJsID0ge1xuICAkdmFsaWRhdG9yOiB1cmwkMSxcbiAgJG1lc3NhZ2U6ICdUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgVVJMIGFkZHJlc3MnLFxuICAkcGFyYW1zOiB7XG4gICAgdHlwZTogJ3VybCdcbiAgfVxufTtcblxuZnVuY3Rpb24gX2F3YWl0JDEodmFsdWUsIHRoZW4sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgcmV0dXJuIHRoZW4gPyB0aGVuKHZhbHVlKSA6IHZhbHVlO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUudGhlbikge1xuICAgIHZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB0aGVuID8gdmFsdWUudGhlbih0aGVuKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBzeW5jT3IodmFsaWRhdG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdmFsaWRhdG9ycy5yZWR1Y2UoKHZhbGlkLCBmbikgPT4ge1xuICAgICAgaWYgKHVud3JhcFZhbGlkYXRvclJlc3BvbnNlKHZhbGlkKSkgcmV0dXJuIHZhbGlkO1xuICAgICAgcmV0dXJuIHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3IoZm4pLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sIGZhbHNlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXN5bmNPcih2YWxpZGF0b3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiB2YWxpZGF0b3JzLnJlZHVjZShmdW5jdGlvbiAodmFsaWQsIGZuKSB7XG4gICAgICByZXR1cm4gX2F3YWl0JDEodmFsaWQsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiB1bndyYXBWYWxpZGF0b3JSZXNwb25zZShyKSA/IHIgOiB1bndyYXBOb3JtYWxpemVkVmFsaWRhdG9yKGZuKS5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9LCBQcm9taXNlLnJlc29sdmUoZmFsc2UpKTtcbiAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIHdoZW4gb25lIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsuLi4oTm9ybWFsaXplZFZhbGlkYXRvcnxGdW5jdGlvbil9IHZhbGlkYXRvcnNcbiAqIEByZXR1cm4ge3skdmFsaWRhdG9yOiBmdW5jdGlvbiguLi5bKl09KTogKGJvb2xlYW4gfCBQcm9taXNlPGJvb2xlYW4+KSwgJGFzeW5jOiBib29sZWFuLCAkd2F0Y2hUYXJnZXRzOiBhbnlbXX19XG4gKi9cblxuXG5mdW5jdGlvbiBvciQxKC4uLnZhbGlkYXRvcnMpIHtcbiAgY29uc3QgJGFzeW5jID0gdmFsaWRhdG9ycy5zb21lKHYgPT4gdi4kYXN5bmMpO1xuICBjb25zdCAkd2F0Y2hUYXJnZXRzID0gdmFsaWRhdG9ycy5yZWR1Y2UoKGFsbCwgdikgPT4ge1xuICAgIGlmICghdi4kd2F0Y2hUYXJnZXRzKSByZXR1cm4gYWxsO1xuICAgIHJldHVybiBhbGwuY29uY2F0KHYuJHdhdGNoVGFyZ2V0cyk7XG4gIH0sIFtdKTtcblxuICBsZXQgJHZhbGlkYXRvciA9ICgpID0+IGZhbHNlO1xuXG4gIGlmICh2YWxpZGF0b3JzLmxlbmd0aCkgJHZhbGlkYXRvciA9ICRhc3luYyA/IGFzeW5jT3IodmFsaWRhdG9ycykgOiBzeW5jT3IodmFsaWRhdG9ycyk7XG4gIHJldHVybiB7XG4gICAgJGFzeW5jLFxuICAgICR2YWxpZGF0b3IsXG4gICAgJHdhdGNoVGFyZ2V0c1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIG9uZSBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Li4uKE5vcm1hbGl6ZWRWYWxpZGF0b3J8RnVuY3Rpb24pfSB2YWxpZGF0b3JzXG4gKiBAcmV0dXJuIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIG9yICguLi52YWxpZGF0b3JzKSB7XG4gIHJldHVybiB3aXRoUGFyYW1zKHtcbiAgICB0eXBlOiAnb3InXG4gIH0sIHdpdGhNZXNzYWdlKCdUaGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBwcm92aWRlZCB2YWxpZGF0b3JzJywgb3IkMSguLi52YWxpZGF0b3JzKSkpO1xufVxuXG5mdW5jdGlvbiBfYXdhaXQodmFsdWUsIHRoZW4sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgcmV0dXJuIHRoZW4gPyB0aGVuKHZhbHVlKSA6IHZhbHVlO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUudGhlbikge1xuICAgIHZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB0aGVuID8gdmFsdWUudGhlbih0aGVuKSA6IHZhbHVlO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvcnNcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLlsqXT0pOiBQcm9taXNlPGJvb2xlYW4+fVxuICovXG5cblxuZnVuY3Rpb24gc3luY0FuZCh2YWxpZGF0b3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIHJldHVybiB2YWxpZGF0b3JzLnJlZHVjZSgodmFsaWQsIGZuKSA9PiB7XG4gICAgICBpZiAoIXVud3JhcFZhbGlkYXRvclJlc3BvbnNlKHZhbGlkKSkgcmV0dXJuIHZhbGlkO1xuICAgICAgcmV0dXJuIHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3IoZm4pLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sIHRydWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhc3luY0FuZCh2YWxpZGF0b3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiB2YWxpZGF0b3JzLnJlZHVjZShmdW5jdGlvbiAodmFsaWQsIGZuKSB7XG4gICAgICByZXR1cm4gX2F3YWl0KHZhbGlkLCBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gdW53cmFwVmFsaWRhdG9yUmVzcG9uc2UocikgPyB1bndyYXBOb3JtYWxpemVkVmFsaWRhdG9yKGZuKS5hcHBseShfdGhpcywgYXJncykgOiByO1xuICAgICAgfSk7XG4gICAgfSwgUHJvbWlzZS5yZXNvbHZlKHRydWUpKTtcbiAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIHdoZW4gYWxsIHZhbGlkYXRvcnMgYXJlIHRydXRoeVxuICogQHBhcmFtIHsuLi4oTm9ybWFsaXplZFZhbGlkYXRvciB8IEZ1bmN0aW9uKX0gdmFsaWRhdG9yc1xuICogQHJldHVybiB7eyR2YWxpZGF0b3I6IGZ1bmN0aW9uKC4uLlsqXT0pOiAoYm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj4pLCAkYXN5bmM6IGJvb2xlYW4sICR3YXRjaFRhcmdldHM6IGFueVtdfX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGFuZCQxKC4uLnZhbGlkYXRvcnMpIHtcbiAgY29uc3QgJGFzeW5jID0gdmFsaWRhdG9ycy5zb21lKHYgPT4gdi4kYXN5bmMpO1xuICBjb25zdCAkd2F0Y2hUYXJnZXRzID0gdmFsaWRhdG9ycy5yZWR1Y2UoKGFsbCwgdikgPT4ge1xuICAgIGlmICghdi4kd2F0Y2hUYXJnZXRzKSByZXR1cm4gYWxsO1xuICAgIHJldHVybiBhbGwuY29uY2F0KHYuJHdhdGNoVGFyZ2V0cyk7XG4gIH0sIFtdKTtcblxuICBsZXQgJHZhbGlkYXRvciA9ICgpID0+IGZhbHNlO1xuXG4gIGlmICh2YWxpZGF0b3JzLmxlbmd0aCkgJHZhbGlkYXRvciA9ICRhc3luYyA/IGFzeW5jQW5kKHZhbGlkYXRvcnMpIDogc3luY0FuZCh2YWxpZGF0b3JzKTtcbiAgcmV0dXJuIHtcbiAgICAkYXN5bmMsXG4gICAgJHZhbGlkYXRvcixcbiAgICAkd2F0Y2hUYXJnZXRzXG4gIH07XG59XG5cbi8qKlxuICogVmFsaWRhdGUgaWYgYWxsIHZhbGlkYXRvcnMgbWF0Y2guXG4gKiBAcGFyYW0gey4uLip9IHZhbGlkYXRvcnNcbiAqIEByZXR1cm5zIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIGFuZCAoLi4udmFsaWRhdG9ycykge1xuICByZXR1cm4gd2l0aFBhcmFtcyh7XG4gICAgdHlwZTogJ2FuZCdcbiAgfSwgd2l0aE1lc3NhZ2UoJ1RoZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbGwgb2YgdGhlIHByb3ZpZGVkIHZhbGlkYXRvcnMnLCBhbmQkMSguLi52YWxpZGF0b3JzKSkpO1xufVxuXG4vKipcbiAqIFN3YXBzIHRoZSByZXN1bHQgb2YgYSB2YWx1ZVxuICogQHBhcmFtIHtOb3JtYWxpemVkVmFsaWRhdG9yfEZ1bmN0aW9ufSB2YWxpZGF0b3JcbiAqIEByZXR1cm5zIHtmdW5jdGlvbigqPSwgKj0pOiBib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIG5vdCQxICh2YWxpZGF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgdm0pIHtcbiAgICBpZiAoIXJlcSh2YWx1ZSkpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gdW53cmFwTm9ybWFsaXplZFZhbGlkYXRvcih2YWxpZGF0b3IpLmNhbGwodGhpcywgdmFsdWUsIHZtKTtcbiAgICBpZiAoIWlzUHJvbWlzZShyZXNwb25zZSkpIHJldHVybiAhdW53cmFwVmFsaWRhdG9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZS50aGVuKHIgPT4gIXVud3JhcFZhbGlkYXRvclJlc3BvbnNlKHIpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTd2FwcyB0aGUgcmVzdWx0IG9mIGEgdmFsdWVcbiAqIEBwYXJhbSB7Tm9ybWFsaXplZFZhbGlkYXRvcnxGdW5jdGlvbn0gdmFsaWRhdG9yXG4gKiBAcmV0dXJucyB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiBub3QgKHZhbGlkYXRvcikge1xuICByZXR1cm4ge1xuICAgICR2YWxpZGF0b3I6IG5vdCQxKHZhbGlkYXRvciksXG4gICAgJG1lc3NhZ2U6IGBUaGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHZhbGlkYXRvcmAsXG4gICAgJHBhcmFtczoge1xuICAgICAgdHlwZTogJ25vdCdcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyIHwgUmVmPE51bWJlcj4gfCBSZWY8U3RyaW5nPn0gbWluXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oKj0pOiBib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIG1pblZhbHVlJDEgKG1pbikge1xuICByZXR1cm4gdmFsdWUgPT4gIXJlcSh2YWx1ZSkgfHwgKCEvXFxzLy50ZXN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICt2YWx1ZSA+PSArdW5yZWYobWluKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBSZWY8TnVtYmVyPiB8IFJlZjxTdHJpbmc+fSBtaW5cbiAqIEByZXR1cm5zIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIG1pblZhbHVlIChtaW4pIHtcbiAgcmV0dXJuIHtcbiAgICAkdmFsaWRhdG9yOiBtaW5WYWx1ZSQxKG1pbiksXG4gICAgJG1lc3NhZ2U6ICh7XG4gICAgICAkcGFyYW1zXG4gICAgfSkgPT4gYFRoZSBtaW5pbXVtIHZhbHVlIGFsbG93ZWQgaXMgJHskcGFyYW1zLm1pbn1gLFxuICAgICRwYXJhbXM6IHtcbiAgICAgIG1pbixcbiAgICAgIHR5cGU6ICdtaW5WYWx1ZSdcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gKiBAcGFyYW0ge051bWJlciB8IFJlZjxOdW1iZXI+IHwgUmVmPFN0cmluZz59IG1heFxuICogQHJldHVybnMge2Z1bmN0aW9uKCo9KTogYm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBtYXhWYWx1ZSQxIChtYXgpIHtcbiAgcmV0dXJuIHZhbHVlID0+ICFyZXEodmFsdWUpIHx8ICghL1xccy8udGVzdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiArdmFsdWUgPD0gK3VucmVmKG1heCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gKiBAcGFyYW0ge051bWJlciB8IFJlZjxOdW1iZXI+IHwgUmVmPFN0cmluZz59IG1heFxuICogQHJldHVybiB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG52YXIgbWF4VmFsdWUgPSAobWF4ID0+ICh7XG4gICR2YWxpZGF0b3I6IG1heFZhbHVlJDEobWF4KSxcbiAgJG1lc3NhZ2U6ICh7XG4gICAgJHBhcmFtc1xuICB9KSA9PiBgVGhlIG1heGltdW0gdmFsdWUgaXMgJHskcGFyYW1zLm1heH1gLFxuICAkcGFyYW1zOiB7XG4gICAgbWF4LFxuICAgIHR5cGU6ICdtYXhWYWx1ZSdcbiAgfVxufSkpO1xuXG4vLyBeLVswLTldKyQgLSBvbmx5IGZvciBuZWdhdGl2ZSBpbnRlZ2VyIChtaW51cyBzaWduIHdpdGhvdXQgYXQgbGVhc3QgMSBkaWdpdCBpcyBub3QgYSBudW1iZXIpXG5cbnZhciBpbnRlZ2VyJDEgPSByZWdleCgvKF5bMC05XSokKXwoXi1bMC05XSskKS8pO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHZhbHVlIGlzIGludGVnZXIuXG4gKiBAdHlwZSB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG52YXIgaW50ZWdlciA9IHtcbiAgJHZhbGlkYXRvcjogaW50ZWdlciQxLFxuICAkbWVzc2FnZTogJ1ZhbHVlIGlzIG5vdCBhbiBpbnRlZ2VyJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJ1xuICB9XG59O1xuXG52YXIgZGVjaW1hbCQxID0gcmVnZXgoL15bLV0/XFxkKihcXC5cXGQrKT8kLyk7XG5cbi8qKlxuICogVmFsaWRhdGUgaWYgdmFsdWUgaXMgZGVjaW1hbCBudW1iZXIuXG4gKiBAdHlwZSB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG52YXIgZGVjaW1hbCA9IHtcbiAgJHZhbGlkYXRvcjogZGVjaW1hbCQxLFxuICAkbWVzc2FnZTogJ1ZhbHVlIG11c3QgYmUgZGVjaW1hbCcsXG4gICRwYXJhbXM6IHtcbiAgICB0eXBlOiAnZGVjaW1hbCdcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNsYXRhYmxlIHZlcnNpb24gb2YgYHdpdGhNZXNzYWdlYCBoZWxwZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0IC0gdGhlIHRyYW5zbGF0aW9uIGZ1bmN0aW9uIG9mIHlvdXIgY2hvaWNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbbWVzc2FnZVBhdGhdIC0gYSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgbWVzc2FnZSBwYXRoLCBwYXNzZWQgdG8gYHRgIGZvciBlYWNoIG1lc3NhZ2UuIEJ5IGRlZmF1bHQgaXQgaXMgYHZhbGlkYXRpb25zLiR7JHZhbGlkYXRvcn1gXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbbWVzc2FnZVBhcmFtc10gLSBhIGZ1bmN0aW9uIHRvIGF1Z21lbnQgdGhlIHBhcmFtcywgcGFzc2VkIHRvIGB0YCBmb3IgZWFjaCBtZXNzYWdlLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUkxOG5NZXNzYWdlKHtcbiAgdCxcbiAgbWVzc2FnZVBhdGggPSAoe1xuICAgICR2YWxpZGF0b3JcbiAgfSkgPT4gYHZhbGlkYXRpb25zLiR7JHZhbGlkYXRvcn1gLFxuICBtZXNzYWdlUGFyYW1zID0gcGFyYW1zID0+IHBhcmFtc1xufSkge1xuICByZXR1cm4gZnVuY3Rpb24gd2l0aEkxOG5NZXNzYWdlKHZhbGlkYXRvciwge1xuICAgIHdpdGhBcmd1bWVudHMgPSBmYWxzZSxcbiAgICBtZXNzYWdlUGF0aDogbG9jYWxNZXNzYWdlUGF0aCA9IG1lc3NhZ2VQYXRoLFxuICAgIG1lc3NhZ2VQYXJhbXM6IGxvY2FsTWVzc2FnZVBhcmFtcyA9IG1lc3NhZ2VQYXJhbXNcbiAgfSA9IHt9KSB7XG4gICAgZnVuY3Rpb24gbWVzc2FnZShwcm9wcykge1xuICAgICAgcmV0dXJuIHQobG9jYWxNZXNzYWdlUGF0aChwcm9wcyksIGxvY2FsTWVzc2FnZVBhcmFtcyhPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbW9kZWw6IHByb3BzLiRtb2RlbCxcbiAgICAgICAgcHJvcGVydHk6IHByb3BzLiRwcm9wZXJ0eSxcbiAgICAgICAgcGVuZGluZzogcHJvcHMuJHBlbmRpbmcsXG4gICAgICAgIGludmFsaWQ6IHByb3BzLiRpbnZhbGlkLFxuICAgICAgICByZXNwb25zZTogcHJvcHMuJHJlc3BvbnNlLFxuICAgICAgICB2YWxpZGF0b3I6IHByb3BzLiR2YWxpZGF0b3IsXG4gICAgICAgIHByb3BlcnR5UGF0aDogcHJvcHMuJHByb3BlcnR5UGF0aFxuICAgICAgfSwgcHJvcHMuJHBhcmFtcykpKTtcbiAgICB9XG5cbiAgICBpZiAod2l0aEFyZ3VtZW50cyAmJiB0eXBlb2YgdmFsaWRhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHdpdGhNZXNzYWdlKG1lc3NhZ2UsIHZhbGlkYXRvciguLi5hcmdzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpdGhNZXNzYWdlKG1lc3NhZ2UsIHZhbGlkYXRvcik7XG4gIH07XG59XG5cbmV4cG9ydCB7IGFscGhhLCBhbHBoYU51bSwgYW5kLCBiZXR3ZWVuLCBjcmVhdGVJMThuTWVzc2FnZSwgZGVjaW1hbCwgZW1haWwsIGNvbW1vbiBhcyBoZWxwZXJzLCBpbnRlZ2VyLCBpcEFkZHJlc3MsIG1hY0FkZHJlc3MsIG1heExlbmd0aCwgbWF4VmFsdWUsIG1pbkxlbmd0aCwgbWluVmFsdWUsIG5vdCwgbnVtZXJpYywgb3IsIHJlcXVpcmVkLCByZXF1aXJlZElmLCByZXF1aXJlZFVubGVzcywgc2FtZUFzLCB1cmwgfTtcbiIsImltcG9ydCAqIGFzIFZ1ZSBmcm9tICd2dWUnXG5cbnZhciBpc1Z1ZTIgPSBmYWxzZVxudmFyIGlzVnVlMyA9IHRydWVcbnZhciBWdWUyID0gdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIGluc3RhbGwoKSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbClcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdGFyZ2V0W2tleV0gPSB2YWxcbiAgcmV0dXJuIHZhbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSlcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV1cbn1cblxuZXhwb3J0ICogZnJvbSAndnVlJ1xuZXhwb3J0IHtcbiAgVnVlLFxuICBWdWUyLFxuICBpc1Z1ZTIsXG4gIGlzVnVlMyxcbiAgaW5zdGFsbCxcbn1cbiIsImltcG9ydCAqIGFzIFZ1ZSBmcm9tICd2dWUnXG5cbnZhciBpc1Z1ZTIgPSBmYWxzZVxudmFyIGlzVnVlMyA9IHRydWVcbnZhciBWdWUyID0gdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIGluc3RhbGwoKSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpXG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbClcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdGFyZ2V0W2tleV0gPSB2YWxcbiAgcmV0dXJuIHZhbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsKHRhcmdldCwga2V5KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSlcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV1cbn1cblxuZXhwb3J0ICogZnJvbSAndnVlJ1xuZXhwb3J0IHtcbiAgVnVlLFxuICBWdWUyLFxuICBpc1Z1ZTIsXG4gIGlzVnVlMyxcbiAgaW5zdGFsbCxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==